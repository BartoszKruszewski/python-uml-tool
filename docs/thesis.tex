\documentclass[polish,inz,longabstract]{iithesis}

\usepackage[utf8]{inputenc}
\usepackage{lipsum}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}


\polishtitle{
    Narzędzie do automatycznego generowania kodu Python na podstawie diagramów UML
}
\englishtitle{
    Tool for automatic Python code generation from UML diagrams
}

\polishabstract{
    Celem pracy jest opracowanie narzędzia automatyzującego proces tworzenia struktury projektów w języku Python na podstawie diagramów UML. Praca została podzielona na dwa etapy. W części analitycznej dokonano przeglądu dostępnych rozwiązań, identyfikując lukę w narzędziach łączących specyfikę środowiska Python z prostą obsługą. Na tej podstawie sformułowano szczegółowe wymagania funkcjonalne i niefunkcjonalne systemu. Część projektowa obejmuje implementację aplikacji w architekturze trójwarstwowej. Przedstawiono autorski algorytm generowania kodu z plików XMI, warstwę serwerową opartą na frameworku FastAPI oraz interfejs użytkownika umożliwiający edycję diagramów. Skuteczność rozwiązania została zweryfikowana poprzez serię testów funkcjonalnych i wydajnościowych.
}

\englishabstract{
    The primary objective of this thesis is the development of a tool designed to automate the process of creating Python project structures based on UML diagrams. The study is organized into two distinct phases. The analytical section provides a review of currently available solutions, identifying a gap in tools that effectively combine the specific characteristics of the Python environment with ease of operation. Consequently, detailed functional and non-functional requirements for the system were formulated. The design section encompasses the implementation of the application utilizing a three-tier architecture. The thesis presents a custom algorithm for generating code from XMI files, a server layer built upon the FastAPI framework, and a user interface facilitating diagram editing. The efficacy of the proposed solution was validated through a comprehensive series of functional and performance tests.
}

\author{Bartosz Kruszewski}

\advisor{dr Marcin Młotkowski}

\transcriptnum {337568}
\advisorgen    {dr Marcin Młotkowski}

\begin{document}

\chapter{Wstęp}

\section{Wprowadzenie do tematyki}

Współczesna inżynieria oprogramowania coraz bardziej koncentruje się na automatyzacji procesów wytwórczych, obejmującej zarządzanie infrastrukturą oraz generowanie kodu źródłowego. Wraz ze wzrostem złożoności systemów informatycznych, kluczowym elementem procesu deweloperskiego stało się modelowanie, a standardem w tej dziedzinie jest język UML (Unified Modeling Language) \cite{omg_uml}. UML umożliwia wizualne przedstawienie architektury systemu przed rozpoczęciem implementacji.

W klasycznym podejściu często występuje rozdźwięk między modelem projektowym a finalnym kodem. Ręczne odwzorowanie diagramów klas na strukturę plików i definicje obiektów jest czasochłonne, powtarzalne i podatne na błędy. Format XMI (XML Metadata Interchange) \cite{omg_xmi} odgrywa kluczową rolę w interoperacyjności narzędzi modelujących, umożliwiając wymianę metadanych modeli UML między różnymi środowiskami.

\section{Uzasadnienie wyboru tematu}

Wybór tematu wynika z obserwacji powszechnego problemu w procesie wytwarzania oprogramowania — braku spójności między fazą projektowania a fazą implementacji. Diagramy UML, traktowane jako fundament architektury, szybko stają się nieaktualne wobec rzeczywistego kodu. Ręczna translacja modeli na kod jest żmudna, mechaniczna i obarczona ryzykiem błędów, co prowadzi do powstawania długu technologicznego już na starcie projektu.

Decyzja o stworzeniu narzędzia automatyzującego ten proces wynika z chęci rozwiązania tego problemu poprzez praktyczne zastosowanie podejścia Model-Driven Development (MDD) \cite{france_mdd}. Komercyjne środowiska CASE (Computer-Aided Software Engineering), takie jak Enterprise Architect czy Visual Paradigm, są często drogie, „ciężkie” oraz oparte na zamkniętym ekosystemie. Istnieje zatem nisza na lekkie, dostępne przez przeglądarkę rozwiązania typu open source, które obniżają próg wejścia do profesjonalnego modelowania systemów.

Projekt odpowiada na rosnącą popularność języka Python w budowaniu złożonych systemów backendowych. W przeciwieństwie do języków silnie typowanych, takich jak Java czy C\#, gdzie generowanie kodu z UML jest standardem, w ekosystemie Pythona brakuje nowoczesnych narzędzi łączących elastyczność języka ze sztywnymi regułami architektonicznymi UML. Stworzenie dedykowanego parsera formatu XMI dla Pythona pozwala na wypełnienie tej luki.

Z perspektywy inżynierskiej, realizacja projektu pozwala pogłębić wiedzę na styku inżynierii oprogramowania, modelowania UML, implementacji parserów struktur danych (XML/XMI) oraz projektowania interfejsów API i aplikacji webowych. Praca umożliwia praktyczne wykorzystanie nowoczesnych rozwiązań full-stack, łącząc teoretyczne aspekty kompilacji i generowania kodu z wyzwaniami współczesnego programowania.

\section{Cel pracy}

Celem pracy jest opracowanie kompleksowego narzędzia wspomagającego proces wytwarzania oprogramowania, umożliwiającego automatyczne generowanie struktury aplikacji w języku Python na podstawie diagramów klas UML. Realizacja celu obejmuje opracowanie dwóch kluczowych komponentów:
\begin{itemize}
    \item Biblioteki Pythonowej służącej do parsowania plików XMI, reprezentujących modele UML, oraz generowania fizycznej struktury projektu: katalogów, plików modułów, definicji klas, atrybutów, metod i relacji. Biblioteka ma zapewniać elastyczność i łatwość integracji z różnymi środowiskami deweloperskimi.

    \item Aplikacji webowej stanowiącej interaktywny edytor diagramów UML, umożliwiający użytkownikowi tworzenie, modyfikowanie i eksportowanie modeli bezpośrednio w przeglądarce. Aplikacja zapewnia wygodny interfejs graficzny oraz komunikację z backendem, który odpowiada za przetworzenie modelu i wygenerowanie kodu źródłowego.
\end{itemize}
Ostatecznym efektem pracy ma być system umożliwiający szybkie prototypowanie aplikacji, zapewniający zgodność między modelem architektonicznym a kodem źródłowym oraz wspierający standaryzację i automatyzację początkowych etapów tworzenia oprogramowania.

\section{Zakres pracy}

Zakres pracy obejmuje projektowanie, implementację oraz testowanie poszczególnych komponentów systemu:
\begin{itemize}
    \item Analizę standardu XMI oraz sposób reprezentacji diagramów klas UML w formacie XML.

    \item Implementację parsera plików XMI w języku Python, wykorzystującego wyłącznie standardowe biblioteki.

    \item Projekt i implementację logiki generowania szkieletu projektu w języku Python, obejmującą tworzenie katalogów, plików modułów, definicji klas, atrybutów, metod oraz relacji dziedziczenia i asocjacji.

    \item Implementację backendu aplikacji webowej w oparciu o framework FastAPI\cite{fastapi}, zapewniającego interfejs API do obsługi żądań generowania kodu oraz eksportu projektu.

    \item Implementację frontendu aplikacji, umożliwiającego interaktywne tworzenie i edycję diagramów klas UML.

    \item Integrację frontendu z backendem poprzez REST API oraz zapewnienie możliwości eksportu modelu w formacie XMI.

    \item Testowanie funkcjonalności generatora kodu oraz aplikacji webowej na wybranych przykładach diagramów UML.

    \item Dokumentację rozwiązania oraz przygotowanie przykładowych przypadków użycia.
\end{itemize}
Praca nie obejmuje implementacji generowania pełnej logiki biznesowej metod (ciała funkcji), a jedynie ich sygnatur oraz struktury architektonicznej wynikającej z modelu UML.

\section{Krótki opis struktury pracy}

Praca została podzielona na dwa główne etapy: analityczny i projektowy.

Etap analityczny (rozdziały 1-2) obejmuje przegląd literatury i istniejących rozwiązań CASE, identyfikację luk rynkowych oraz sformułowanie wymagań funkcjonalnych i niefunkcjonalnych systemu.

Etap projektowy (rozdziały 3-5) opisuje architekturę trójwarstwową aplikacji, implementację kluczowych modułów (parser XMI, generator kodu Python, frontend JS), testy jednostkowe (pytest) oraz instrukcję obsługi.

Zakończenie (rozdział 6) zawiera podsumowanie, ocenę realizacji celów oraz perspektywy rozwoju (obsługa innych diagramów UML, języków programowania).

\chapter{Analiza dziedziny i przegląd narzędzi}

\section{Opis problemu}

W procesie wytwarzania oprogramowania programiści często poświęcają dużo czasu na ręczne przygotowanie struktury projektu: tworzenie katalogów, plików, klas i ich zależności. W przypadku dużych systemów, zwłaszcza modelowanych za pomocą UML, ten etap wiąże się z ryzykiem błędów, niespójności między modelem a kodem oraz wydłużeniem czasu rozpoczęcia właściwej implementacji.

W praktyce, wiele zespołów napotyka trudności z utrzymaniem zgodności architektury (UML) z rzeczywistym kodem. Ręczne tworzenie struktury prowadzi do powstawania „długów technologicznych” - model szybko staje się nieaktualny, a zmiany wymagają wielokrotnego ręcznego aktualizowania kodu. Brak standaryzacji utrudnia pracę zespołową oraz automatyzację testów i integracji ciągłej.

Istniejące narzędzia CASE generują kod z UML, ale są często kosztowne, wymagają instalacji ciężkich aplikacji desktopowych i nie są elastyczne. Brakuje lekkich, otwartych rozwiązań umożliwiających szybkie prototypowanie, automatyzację tworzenia struktury projektu oraz ciągłą synchronizację modelu z kodem.

Celem projektu jest eliminacja tych problemów poprzez stworzenie lekkiego, webowego narzędzia do szybkiego i spójnego generowania szkieletu aplikacji Pythonowej na podstawie diagramów UML, co przekłada się na większą efektywność, mniejszą liczbę błędów i lepszą standaryzację architektury projektów.

\section{Przegląd istniejących, konkurencyjnych rozwiązań}

Rynek narzędzi wspierających modelowanie w języku UML jest silnie spolaryzowany. Z jednej strony dominują rozbudowane, komercyjne systemy CASE, z drugiej - proste edytory graficzne dostępne przez przeglądarkę. Analiza dostępnych rozwiązań pozwala wyodrębnić cztery główne grupy narzędzi, z których każda posiada istotne ograniczenia w kontekście szybkiego prototypowania aplikacji Pythonowych.

Pierwszą grupę stanowią zaawansowane środowiska CASE, takie jak Enterprise Architect \cite{enterprise_arch} czy Visual Paradigm \cite{visual_paradigm}. Są to kompletne platformy inżynierskie oferujące pełną obsługę standardu XMI, inżynierię zwrotną oraz wbudowane generatory kodu. Ich główną wadą jest jednak "ciężkość" (wymóg instalacji desktopowej), wysoki koszt licencji oraz wysoki próg wejścia wynikający ze skomplikowanego interfejsu. Są to narzędzia dedykowane dla architektów korporacyjnych, a nie dla zwinnych zespołów deweloperskich.

Drugą kategorię tworzą lekkie narzędzia desktopowe, reprezentowane przez StarUML \cite{staruml}. Oferują one znacznie lepszy UX niż systemy korporacyjne, jednak ich funkcjonalność w zakresie generowania kodu (szczególnie dla Pythona) opiera się na wtyczkach tworzonych przez społeczność, które często są nieaktualne lub porzucane. Ponadto, wciąż wymagają one instalacji lokalnej, co utrudnia pracę w chmurze.

Trzecią grupą są webowe edytory graficzne, takie jak draw.io (diagrams.net) \cite{drawio}. Cieszą się one ogromną popularnością ze względu na darmowy dostęp i brak konieczności instalacji. Są to jednak narzędzia stricte do rysowania - nie posiadają semantycznego rozumienia obiektów UML. Traktują diagram jako zbiór kształtów, a nie strukturę klas, co w połączeniu z brakiem obsługi formatu XMI całkowicie wyklucza je z procesów automatycznego generowania kodu.

Czwartą grupę stanowią narzędzia typu "Code-as-Diagram", np. PlantUML \cite{plantuml}. Choć są one standardem w dokumentowaniu kodu (model Open Source), nie służą do modelowania architektury w rozumieniu MDD. Nie przechowują one modelu w uniwersalnym formacie metadanych, lecz jedynie renderują obraz na podstawie tekstu, co uniemożliwia dwukierunkową synchronizację z kodem.

\section{Analiza ich wad i zalet}

\begin{table}[h!]
    \centering
    \footnotesize
    \begin{tabular}{|l|l|l|l|l|l|}
        \hline
        \textbf{Narzędzie} & 
        \textbf{Kategoria} & 
        \textbf{Platforma} & 
        \textbf{Licencja} & 
        \textbf{XMI} & 
        \textbf{Python} \\ 
        \hline
        Enterprise Architect & 
        Zaawansowane & 
        Desktop & 
        Komercyjna & 
        Pełne & 
        Tak \\ 
        \hline
        Visual Paradigm & 
        Zaawansowane & 
        Desktop & 
        Subskrypcja & 
        Pełne & 
        Tak \\ 
        \hline
        StarUML & 
        Lekkie & 
        Desktop & 
        Komercyjna & 
        Częściowe & 
        Częściowo \\ 
        \hline
        PlantUML & 
        Code-as-Diagram & 
        IDE/CLI & 
        Open Source & 
        Brak & 
        Brak \\ 
        \hline
        draw.io & 
        Edytor graficzny & 
        Web & 
        Darmowa & 
        Brak & 
        Brak \\ 
        \hline
    \end{tabular}
    \caption{Porównanie wybranych narzędzi CASE i UML}
    \label{tab:narzedzia_case}
\end{table}


Analiza wykazuje wyraźną lukę rynkową. Brakuje narzędzia, które łączyłoby zalety edytorów webowych (dostępność, brak instalacji) z inżynierską precyzją systemów CASE (obsługa XMI, generowanie kodu), będąc jednocześnie rozwiązaniem Open Source dedykowanym specyfice języka Python. Projektowane rozwiązanie ma na celu wypełnienie tej niszy.

\chapter{Analiza wymagań i projekt systemu}

\section{Wymagania funkcjonalne}

\subsection{Tworzenie i edycja diagramów klas UML}

\begin{enumerate}[label=\textbf{WF-\arabic*}, leftmargin=*, align=left, font=\bfseries, labelsep=1em]

\subsubsection{Tworzenie klas}
    \item System umożliwia użytkownikowi dodawanie klas do diagramu.
    \item Użytkownik może nadać klasie nazwę.
    \item Użytkownik może zdefiniować atrybuty klasy (nazwa, typ).
    \item Użytkownik może zdefiniować operacje klasy (nazwa, parametry, typ zwracany).
    \item Użytkownik może przypisać klasę do pakietu.

\subsubsection{Tworzenie pakietów}
    \item System umożliwia użytkownikowi dodawanie pakietów do diagramu.
    \item Użytkownik może nadać pakietowi nazwę.
    \item System obsługuje zagnieżdżone pakiety.
    \item Użytkownik może organizować klasy w pakietach.

\subsubsection{Definiowanie relacji}
    \item System umożliwia tworzenie relacji między klasami.
    \item System obsługuje następujące typy relacji: asocjacja, agregacja, kompozycja, dziedziczenie, realizacja, zależność.
    \item Użytkownik może określić kierunek relacji.

\subsubsection{Edycja elementów}
    \item Użytkownik może modyfikować właściwości klas (nazwa, atrybuty, operacje).
    \item Użytkownik może modyfikować właściwości pakietów (nazwa).
    \item Użytkownik może usuwać klasy i pakiety.
    \item Użytkownik może usuwać relacje.

\subsubsection{Wizualizacja diagramu}
    \item System wyświetla diagram w formie graficznej.
    \item System renderuje klasy jako prostokąty z sekcjami (nazwa, atrybuty, operacje).
    \item System renderuje pakiety jako kontenery.
    \item System renderuje relacje jako linie między klasami.
    \item System wyświetla widok drzewa struktury pakietów i klas.

\subsection{Eksport i import diagramów}

\subsubsection{Eksport do XMI}
    \item System eksportuje diagram do formatu XMI 2.1.
    \item Wyeksportowany plik jest zgodny ze standardem OMG.
    \item Plik XMI zawiera wszystkie elementy diagramu (klasy, pakiety, relacje).

\subsubsection{Import XMI}
    \item System może parsować pliki XMI 2.1.
    \item System obsługuje podstawowe elementy XMI (klasy, pakiety, relacje, typy danych).
    \item System waliduje poprawność formatu XMI.

\subsection{Generowanie kodu Python}

\subsubsection{Generowanie struktury projektu}
    \item System generuje strukturę katalogów odpowiadającą pakietom.
    \item System tworzy pliki \texttt{\_\_init\_\_.py} dla każdego pakietu.
    \item System generuje pliki \texttt{.py} dla każdej klasy.

\subsubsection{Generowanie klas}
    \item System generuje definicje klas Python z odpowiednią składnią.
    \item System mapuje atrybuty UML na właściwości klasy.
    \item System generuje konstruktory z parametrami odpowiadającymi atrybutom.
    \item System generuje metody odpowiadające operacjom UML.
    \item System używa type hints \cite{pep484} dla parametrów i zwracanych wartości.

\subsubsection{Mapowanie typów}
    \item System mapuje standardowe typy UML na typy Python (\texttt{String} $\to$ \texttt{str}, \texttt{Integer} $\to$ \texttt{int}, \texttt{Float} $\to$ \texttt{float}).
    \item System zachowuje nazwy niestandardowych typów (klasy użytkownika).

\subsubsection{Obsługa relacji w kodzie}
    \item System generuje odpowiedni kod dla różnych typów relacji (asocjacja, agregacja, kompozycja, dziedziczenie/realizacja, zależność).

\subsubsection{Zarządzanie importami}
    \item System automatycznie generuje instrukcje \texttt{import} dla używanych klas.
    \item System generuje poprawne ścieżki importu na podstawie struktury pakietów.
    \item System obsługuje importy z zagnieżdżonych pakietów.

\subsubsection{Eksport wygenerowanego projektu}
    \item System pakuje wygenerowany projekt do archiwum ZIP.
    \item Użytkownik może pobrać archiwum ZIP z wygenerowanym kodem.
    \item Archiwum zawiera kompletną strukturę projektu gotową do użycia.

\subsection{Interfejs użytkownika}

\subsubsection{Interakcje użytkownika}
    \item Użytkownik może przeciągać elementy na diagramie.
    \item Użytkownik może zaznaczać elementy klikając na nie.
    \item Użytkownik może edytować elementy w panelach edycji.
    \item Użytkownik może używać widoku drzewa do nawigacji po strukturze.

\subsubsection{Operacje na diagramie}
    \item Użytkownik może czyścić cały diagram.
    \item Użytkownik może generować kod z aktualnego diagramu.

\end{enumerate}

\section{Wymagania niefunkcjonalne}

\subsection{Wydajność}

\begin{enumerate}[label=\textbf{WNF-\arabic*}, leftmargin=*, align=left, font=\bfseries, labelsep=1em]

\subsubsection{Czas odpowiedzi}
    \item Generowanie kodu dla projektu z maksymalnie 100 klas powinno zakończyć się w czasie poniżej 5 sekund.
    \item Renderowanie diagramu powinno być płynne (minimum 30 FPS).
    \item Interfejs powinien reagować na akcje użytkownika w czasie poniżej 100ms.

\subsubsection{Skalowalność}
    \item System powinien obsługiwać diagramy z maksymalnie 1000 klas.
    \item System powinien obsługiwać zagnieżdżone pakiety do 10 poziomów głębokości.

\subsection{Użyteczność}

\subsubsection{Intuicyjność}
    \item Interfejs powinien być intuicyjny i nie wymagać szkolenia.
    \item Operacje powinny być dostępne w maksymalnie 3 kliknięciach.
    \item System powinien wyświetlać pomocne etykiety.

\subsubsection{Dostępność}
    \item Aplikacja powinna działać w nowoczesnych przeglądarkach (Chrome, Firefox, Safari, Edge).
    \item Interfejs powinien być responsywny i dostosowywać się do różnych rozdzielczości ekranu.

\subsection{Niezawodność}

\subsubsection{Obsługa błędów}
    \item System powinien walidować dane wejściowe (pliki XMI).
    \item System nie powinien tracić danych przy błędach parsowania.

\subsubsection{Stabilność}
    \item System nie powinien zawieszać się podczas normalnego użytkowania.
    \item Błędy w jednym komponencie nie powinny wpływać na cały system.

\subsection{Kompatybilność}

\subsubsection{Standardy}
    \item System powinien być zgodny ze standardem XMI 2.1.
    \item Wygenerowany kod powinien być zgodny z Python 3.11+.
    \item System powinien używać type hints zgodnie z PEP 484.

\subsubsection{Integracja}
    \item System powinien być kompatybilny z innymi narzędziami UML eksportującymi XMI 2.1.
    \item Wygenerowany kod powinien być kompatybilny z popularnymi narzędziami Python (pip, setuptools).

\subsection{Utrzymanie i rozwój}

\subsubsection{Modułowość}
    \item Kod powinien być podzielony na logiczne moduły.
    \item Warstwa domeny powinna być niezależna od warstwy aplikacji.
    \item Komponenty powinny być łatwe do testowania.

\subsubsection{Dokumentacja}
    \item Kod powinien zawierać dokumentację docstring.
    \item System powinien mieć dokumentację użytkownika.
    \item System powinien mieć dokumentację techniczną dla programistów.

\subsection{Bezpieczeństwo}

\subsubsection{Bezpieczeństwo danych}
    \item System nie przechowuje danych użytkownika po zakończeniu sesji.
    \item Pliki tymczasowe są automatycznie usuwane.
\end{enumerate}

\section{Historyjki użytkownika}

\begin{enumerate}[label=\textbf{HU-\arabic*}, leftmargin=*, align=left, font=\bfseries, labelsep=1em]
    
    \item \textbf{Tworzenie nowego diagramu} \\
    \textbf{Jako} programista Python \textbf{chcę} utworzyć nowy diagram klas UML, \textbf{aby} zaprojektować strukturę mojego projektu przed rozpoczęciem kodowania. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę dodać klasę do diagramu jednym kliknięciem.
        \item Mogę nadać klasie nazwę i zdefiniować jej atrybuty oraz metody.
        \item Widzę diagram wizualnie na ekranie.
    \end{itemize}

    \item \textbf{Organizacja klas w pakietach} \\
    \textbf{Jako} programista Python \textbf{chcę} organizować klasy w pakietach, \textbf{aby} odzwierciedlić strukturę modułów w moim projekcie. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę utworzyć pakiet i nadać mu nazwę.
        \item Mogę przypisać klasy do pakietów.
        \item Mogę tworzyć zagnieżdżone pakiety.
        \item Widzę strukturę pakietów w widoku drzewa.
    \end{itemize}

    \item \textbf{Definiowanie relacji między klasami} \\
    \textbf{Jako} programista Python \textbf{chcę} zdefiniować relacje między klasami, \textbf{aby} zaprojektować zależności i powiązania w moim systemie. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę utworzyć relację między dwiema klasami.
        \item Mogę wybrać typ relacji.
        \item Relacja jest wizualnie wyświetlana na diagramie.
    \end{itemize}

    \item \textbf{Generowanie kodu z diagramu} \\
    \textbf{Jako} programista Python \textbf{chcę} wygenerować kod Python z mojego diagramu, \textbf{aby} szybko stworzyć szkielet projektu bez ręcznego pisania kodu. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę wygenerować kod jednym kliknięciem.
        \item Otrzymuję archiwum ZIP z kompletnym projektem.
        \item Wygenerowany kod zawiera wszystkie klasy z diagramu.
        \item Struktura katalogów odpowiada pakietom w diagramie.
    \end{itemize}

    \item \textbf{Import istniejącego diagramu} \\
    \textbf{Jako} programista Python \textbf{chcę} zaimportować diagram z pliku XMI, \textbf{aby} kontynuować pracę nad diagramem. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę zaimportować plik XMI 2.1.
        \item Wszystkie elementy diagramu są poprawnie załadowane.
        \item Mogę edytować zaimportowany diagram.
    \end{itemize}

    \item \textbf{Edycja właściwości klasy} \\
    \textbf{Jako} programista Python \textbf{chcę} edytować właściwości klasy (atrybuty, metody), \textbf{aby} dostosować klasę do moich potrzeb. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę zaznaczyć klasę i zobaczyć jej właściwości w panelu edycji.
        \item Mogę modyfikować nazwę, atrybuty i operacje klasy.
        \item Zmiany są natychmiast widoczne na diagramie.
    \end{itemize}

    \item \textbf{Eksport diagramu do XMI} \\
    \textbf{Jako} programista Python \textbf{chcę} wyeksportować mój diagram do formatu XMI, \textbf{aby} użyć go w innych narzędziach UML lub zachować jako backup. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę wyeksportować diagram do pliku XMI.
        \item Wyeksportowany plik jest zgodny ze standardem XMI 2.1.
        \item Mogę zaimportować wyeksportowany plik z powrotem.
    \end{itemize}

    \item \textbf{Wizualizacja struktury projektu} \\
    \textbf{Jako} programista Python \textbf{chcę} zobaczyć hierarchiczną strukturę mojego projektu, \textbf{aby} lepiej zrozumieć organizację pakietów i klas. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Widzę drzewo pakietów i klas w osobnym panelu.
        \item Mogę kliknąć element w drzewie, aby go zaznaczyć na diagramie.
        \item Struktura jest aktualizowana w czasie rzeczywistym.
    \end{itemize}

    \item \textbf{Szybkie prototypowanie} \\
    \textbf{Jako} programista Python \textbf{chcę} szybko stworzyć szkielet projektu, \textbf{aby} rozpocząć implementację bez tracenia czasu na ręczne tworzenie plików. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę szybko utworzyć podstawowy diagram z kilkoma klasami.
        \item Generowanie kodu jest szybkie (poniżej 5 sekund dla małych projektów).
        \item Wygenerowany kod jest gotowy do użycia.
    \end{itemize}

    \item \textbf{Nauka UML} \\
    \textbf{Jako} student informatyki \textbf{chcę} używać narzędzia do nauki UML, \textbf{aby} zrozumieć koncepcje modelowania obiektowego. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Interfejs jest intuicyjny i nie wymaga szkolenia.
        \item Mogę eksperymentować z różnymi typami relacji.
        \item Widzę jak diagramy UML przekładają się na kod Python.
    \end{itemize}

    \item \textbf{Współpraca w zespole} \\
    \textbf{Jako} członek zespołu programistów \textbf{chcę} udostępnić mój diagram innym, \textbf{aby} omówić architekturę projektu przed implementacją. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę wyeksportować diagram do standardowego formatu (XMI).
        \item Inni członkowie zespołu mogą zaimportować diagram w swoich narzędziach.
        \item Diagram jest czytelny i zrozumiały dla innych.
    \end{itemize}

\end{enumerate}

\section{Architektura systemu}

Architektura systemu jest oparta na wzorcu trójwarstwowym, co gwarantuje modułowość rozwiązania oraz wyraźną separację odpowiedzialności poszczególnych komponentów. \cite{clean_arch}

W strukturze projektu wyróżnia się trzy współpracujące ze sobą warstwy:
\begin{itemize}

    \item Warstwa prezentacji - stanowi interaktywny frontend zaimplementowany w języku JavaScript. Odpowiada ona za dynamiczne renderowanie diagramów w technologii SVG, zarządzanie złożonym stanem wizualnym oraz obsługę dwukierunkowej konwersji danych do standardu XMI 2.1.

    \item Warstwa aplikacji - funkcjonuje jako backend oparty na frameworku FastAPI (Python). Pełni rolę serwera REST API, który obsługuje komunikację HTTP i koordynuje przepływ danych między interfejsem użytkownika a silnikiem generującym kod.

    \item Warstwa domeny - realizuje kluczową logikę biznesową w izolacji od warstwy sieciowej. Moduł ten odpowiada za parsowanie struktur UML, mapowanie relacji między obiektami oraz automatyczną generację wynikowych plików i katalogów w języku Python.

\end{itemize}

\chapter{Charakterystyka narzędzi i środowiska}

\section{Języki programowania i framework}

Aplikacja jest przeznaczona do generowania kodu Python, co naturalnie wpłynęło na wybór języka dla warstwy domenowej. W celu minimalizacji zależności zewnętrznych w tej warstwie wykorzystane zostały wyłącznie biblioteki standardowe.

Warstwa aplikacji została zbudowana w oparciu o Python i framework FastAPI. FastAPI wyróżnia się swoją lekkością i prostotą architektoniczną, co czyni go idealnym rozwiązaniem dla małych serwisów udostępniających REST API. W porównaniu z popularnymi alternatywami takimi jak Flask czy Django, oferuje on znacznie bardziej minimalistyczne podejście przy jednoczesnie wyższej wydajności, choć kosztem mniejszej liczby wbudowanych funkcjonalności. Biorąc pod uwagę relatywnie prostą strukturę warstwy aplikacji, FastAPI okazał się wyborem optymalnym.

Warstwa prezentacji została oparta na HTML, CSS, JavaScript i Bootstrap, bez wykorzystania dedykowanego frameworka. Ta decyzja architektoniczna wynika z faktu, że interfejs użytkownika nie wymaga złożonej logiki - użycie frameworka frontendowego mogłoby zaciemnić strukturę kodu zamiast ją uprościć. Ponieważ rozmiar kodu odpowiada przede wszystkim za efekt wizualny a nie funkcjonalny aplikacji, wprowadzenie rozwiązań takich jak React nie przyniosłoby żadnych rzeczywistych korzyści.

\section{Narzędzia}

Projekt wykorzystuje Git jako narzędzie do kontroli wersji. Ze względu na modularność warstwy domenowej, która może być autonomicznie wykorzystywana w innych projektach, repozytorium podzielone zostało na dwie części - główne repozytorium aplikacji oraz submoduł zawierający warstwę domenową, oba udostępnione na platformie GitHub.

Zarządzanie zależnościami zewnętrznymi realizowane jest za pośrednictwem venv (służącego do utworzenia izolowanych środowisk Python) oraz pip (odpowiedzialnego za pobieranie i instalację pakietów). Wszystkie wymagane biblioteki zostały dokładnie zdefiniowane w plikach pyproject.toml, zapewniając pełną reprodukowalność środowiska.

Testowanie aplikacji prowadzone jest przy użyciu frameworka pytest \cite{pytest_okken}, stanowiącego standard w ekosystemie Python.

\chapter{Implementacja rozwiązania}

\section{Opis struktury projektu}

Aplikacja opiera się na trójwarstwowej architekturze, gdzie każda warstwa odpowiada za określone aspekty funkcjonalności.

\subsection{Warstwa domeny}

Warstwa domeny odpowiada za przetwarzanie diagramów UML i generowanie kodu Python. Jej zadaniem jest konwersja modelu UML z formatu XMI na gotową do użytku strukturę projektu.

\begin{itemize}
    \item syntax.py - definiuje wewnętrzną reprezentację modelu UML
    \item XmiParser.py - parsuje pliki XMI zgodnie ze standardem XMI 2.1
    \item ProjectGenerator.py - generuje strukturę katalogów i pliki projektu Python
    \item TemplateManager.py - renderuje kod Python na podstawie obiektów modelu, obsługuje mapowanie typów i relacji
    \item ImportMapping.py - zarządza mapowaniem klas na ścieżki importu w wygenerowanym projekcie
\end{itemize}

System w pełni obsługuje wszystkie podstawowe relacje UML (asocjacja, agregacja, kompozycja, dziedziczenie, realizacja, zależność) i mapuje je semantycznie na idiomatyczny kod Python.

\subsection{Warstwa aplikacji}

Backend udostępnia interfejs API do komunikacji między frontendem a logiką generowania kodu.

Główne endpointy:

\begin{itemize}
    \item GET / - serwuje interfejs użytkownika
    \item POST /generate - przyjmuje plik XMI i zwraca wygenerowany projekt jako archiwum ZIP
\end{itemize}

Proces generowania obejmuje:

\begin{itemize}
    \item Walidację przesłanego pliku
    \item Parsowanie struktury XMI
    \item Generowanie kodu Python
    \item Pakowanie wyników w archiwum ZIP
    \item Obsługę błędów na każdym etapie
\end{itemize}

\subsection{Warstwa prezentacji}

Frontend jest aplikacją modułową, gdzie każdy komponent odpowiada za określoną funkcjonalność.

Zarządzanie stanem i renderowaniem:
\begin{itemize}
    \item DiagramState.js - przechowuje modelowe dane (klasy, pakiety, relacje, zoom, pan)
    \item SvgRenderer.js - renderuje diagram w formacie SVG na podstawie stanu
\end{itemize}

Interakcja użytkownika:
\begin{itemize}
    \item InteractionController.js - obsługuje gesty (przeciąganie, pan, zoom, resize)
    \item LinkService.js - umożliwia tworzenie i zarządzanie relacjami między klasami
\end{itemize}

Wymiana danych:
\begin{itemize}
    \item Exporter.js - eksportuje diagram do standardu XMI 2.1 z obsługą pakietów zagnieżdżonych
    \item XmiImporter.js - importuje pliki XMI i automatycznie pozycjonuje elementy na diagramie
    \item GenerateService.js - komunikuje się z API backendu w celu generowania kodu
\end{itemize}

Interfejs użytkownika:
\begin{itemize}
    \item EditorsUI.js - panele do edycji właściwości klas i pakietów
    \item TreeUI.js - hierarchiczny widok drzewa z wskazaniem zagnieżdzenia i relacji
    \item Coordinate.js - funkcje transformacji i konwersji współrzędnych
    \item Geometry.js - obliczenia geometryczne dla renderowania i interakcji
\end{itemize}

\section{Przepływ danych}

\begin{enumerate}
    \item Użytkownik tworzy diagram (Frontend)
    \item Export do XMI (Exporter.js)
    \item Wysłanie na backend (GenerateService.js)
    \item Parsowanie XMI (XmiParser.py)
    \item Generowanie kodu Python (ProjectGenerator.py + TemplateManager.py)
    \item Zwrócenie archiwum ZIP
    \item Pobranie przez użytkownika
\end{enumerate}

\section{Prezentacja interfejsu użytkownika}

Sekcja prezentuje wizualną realizację warstwy prezentacji aplikacji webowej, zbudowanej w technologiach HTML, CSS i JavaScript z renderowaniem diagramów w SVG. Interfejs zapewnia intuicyjną obsługę wszystkich funkcjonalności zdefiniowanych w historyjkach użytkownika.

\subsection{Widok główny aplikacji}
Główny ekran aplikacji udostępnia trzy kluczowe panele: obszar rysowania diagramu, pasek narzędzi oraz hierarchiczne drzewo struktury projektu.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.95\textwidth]{img/main_view.png}
\caption{Główny widok aplikacji z paskiem narzędzi, obszarem rysowania i drzewem struktury.}
\label{fig:glowny_widok}
\end{figure}

Pasek narzędzi (dolna część rys. \ref{fig:glowny_widok}) zawiera przyciski do podstawowych operacji: dodawania klas (\emph{Add Class}), pakietów (\emph{Add Package}), tworzenia relacji (\emph{Link Mode}), eksportu/importu XMI oraz generowania kodu (\emph{Generate}). Obszar rysowania wspiera gesty przeciągania, zoom (kółko myszy) i panowanie (spacja + przeciąganie).

\section{Tworzenie i edycja elementów}
Interfejs umożliwia definiowanie pełnych klas UML z atrybutami, operacjami i przypisaniem do pakietów poprzez dedykowane panele edycji.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\textwidth]{img/edit_class.png}
\caption{Panel edycji klasy z zdefiniowanymi atrybutami, operacjami i mapowaniem typów.}
\label{fig:edycja_klasy}
\end{figure}

Na rys. \ref{fig:edycja_klasy} widoczny jest panel edycji klasy \emph{UserService} z atrybutami typowanymi (\texttt{user\_id: int}, \texttt{email: str}) i operacjami z type hints (\texttt{create\_user(email: str) → User}).

\subsection{Organizacja w pakietach i relacje}
Pakiety umożliwiają hierarchiczną organizację klas odpowiadającą strukturze modułów Pythona. Relacje między klasami renderowane są jako skierowane linie z odpowiednimi oznaczeniami UML.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.95\textwidth]{img/packages_relations.png}
\caption{Hierarchia pakietów z relacjami: dziedziczenie, kompozycja i asocjacja.}
\label{fig:pakiety_relacje}
\end{figure}

Rysunek \ref{fig:pakiety_relacje} pokazuje zagnieżdżoną strukturę pakietów \emph{services/user} → \emph{services}, klasę \emph{UserRepository} kompozytującą \emph{DatabaseConnection} (czarna diament) oraz dziedziczenie \emph{AdminUser} po \emph{User} (pusta strzałka). Widok drzewa po lewej synchronizuje się z diagramem.

\chapter{Testowanie i weryfikacja}

\section{Zakres Testowania}

Testowanie obejmowało kluczowe aspekty funkcjonalne aplikacji, w szczególności przetwarzanie danych XMI, generowanie kodu oraz mapowanie struktury projektów. Weryfikacji poddano następujące elementy: parsowanie pakietów, klas i relacji z plików XMI, generowanie kodu Python z zachowaniem hierarchii pakietów, prawidłowe mapowanie importów dla zagnieżdżonych struktur pakietów oraz obsługę wszystkich typów relacji UML. Dodatkowo przeprowadzono weryfikację poprawności generowania plików projektu i inicjalizacji pakietów w wygenerowanym kodzie.

\section{Testy Jednostkowe}

Zestaw testów jednostkowych implementowanych z wykorzystaniem frameworka pytest obejmował cztery główne komponenty aplikacji:

\begin{itemize}
    \item ImportMapping - Weryfikacja mechanizmu mapowania ścieżek importów dla klas w zagnieżdżonych pakietach, w tym obsługę scenariuszy z wieloma klasami w jednym pakiecie, klasami rozproszonymi w różnych pakietach oraz przypadkami zawierającymi brakujące klasy.

    \item ProjectGenerator - Testowanie procesu tworzenia struktury katalogów dla projektów o różnym stopniu złożoności: pakiety puste, struktury płaskie oraz zagnieżdżone hierarchie pakietów, z weryfikacją obecności plików i prawidłowego generowania plików klas ze skeletami kodu.

    \item TemplateManager - Walidacja poprawności generowania definicji klas z właściwościami i operacjami, a także obsługa wszystkich typów relacji UML (asocjacja, agregacja, kompozycja, dziedziczenie, realizacja, zależność) w generowanym kodzie.

    \item XmiParser - Testowanie parsowania plików XMI o różnych strukturach, w tym pakiety puste i zagnieżdżone, klasy bez pól i metod, wszystkie typy relacji, właściwości i operacje bez jawnie zdefiniowanych typów oraz walidacja obsługi błędnego lub niekompletnego XMI.
\end{itemize}

\section{Testy Manualne}

Testowanie manualne przeprowadzono w celu weryfikacji aspektów interfejsu użytkownika i wizualizacji, które nie mogą być w pełni ocenione przez testy automatyczne. Obejmowało to: sprawdzenie poprawności eksportu i importu plików XMI poprzez interfejs graficzny oraz weryfikację wizualizacji diagramu UML w formacie SVG, w szczególności poprawne renderowanie relacji między komponentami.

\section{Wnioski z Testowania}

Testy jednostkowe wykonane z użyciem pytest przebiegły pomyślnie i wykazały, że implementacja pokrywa główne scenariusze użycia aplikacji: import i przetwarzanie plików XMI, mapowanie struktur pakietów i klas, generowanie hierarchii projektów oraz prawidłową obsługę wszystkich typów relacji UML. Testy manualne potwierdziły intuicyjność interfejsu użytkownika oraz poprawne działanie podstawowych operacji na diagramach.

Przeprowadzone testowanie wykazało, że wszystkie wymagania funkcjonalne zdefiniowane w sekcji historyjek użytkownika zostały spełnione. Aplikacja poprawnie obsługuje eksport i import danych w formacie XMI, zapewnia logiczną organizację pakietów oraz umożliwia definiowanie złożonych relacji między komponentami modelu. Dodatkowo system generuje kod Python zachowujący strukturę diagramu UML, co stanowi zasadniczy cel aplikacji.

\chapter{Instrukcja Obsługi Narzędzia UML}

\section{Wprowadzenie}

Narzędzie UML jest zaawansowaną aplikacją webową do tworzenia diagramów klas UML z możliwością automatycznego generowania kodu Python. Intuicyjny interfejs pozwala użytkownikom na szybkie i efektywne modelowanie systemów informatycznych bez konieczności ręcznego pisania kodu.

\section{Wdrożenie Aplikacji}

\subsection{Instalacja Zależności}

Przed pierwszym uruchomieniem aplikacji zainstaluj wymagane pakiety:

\begin{lstlisting}[language=Bash]
pip install -e domain
pip install -e .
\end{lstlisting}

\subsection{Uruchamianie Serwera}

Aby uruchomić aplikację, wykonaj polecenie:

\begin{lstlisting}[language=Bash]
python run.py
\end{lstlisting}

Aplikacja będzie dostępna w przeglądarce internetowej pod adresem \url{https://localhost:8080}.

\section{Omówienie Interfejsu}

Interfejs użytkownika podzielony jest na kilka logicznych sekcji:

\begin{table}[h!]
    \centering
    \footnotesize
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Komponent} &
        \textbf{Opis} \\ \hline
        \textbf{Obszar rysowania} &
        Główne pole robocze do tworzenia diagramów \\ \hline
        \textbf{Pasek narzędzi} &
        Przyciski do operacji na diagramach \\ \hline
        \textbf{Widok drzewa} &
        Hierarchiczna struktura pakietów i klas \\ \hline
        \textbf{Panele edycji} &
        Edytory właściwości wybranych elementów \\ \hline
    \end{tabular}
    \caption{Podstawowe komponenty interfejsu aplikacji do edycji diagramów UML}
    \label{tab:intrukcja_uml_komponenty}
\end{table}

\subsection{Obszar Rysowania}

Obszar rysowania stanowi główne pole robocze aplikacji, gdzie umieszczone są wszystkie elementy diagramu. W tym obszarze możesz wykonywać poniższe operacje:

Operacje na elementach:
\begin{itemize}
    \item Przesuwanie elementów - Kliknij i przytrzymaj element, następnie przeciągnij go w żądane miejsce
    \item Zaznaczanie - Kliknij na element, aby go zaznaczyć i uaktywnić panel edycji
    \item Przesuwanie widoku - Przeciągnij pusty obszar kanwy lub przytrzymaj klawisz spacji i przeciągnij, aby przesunąć widok
    \item Zmiana skali - Użyj kółka myszy do przybliżania i oddalania widoku
\end{itemize}

\subsection{Pasek Narzędzi}

Pasek narzędzi zlokalizowany na dole ekranu zawiera przyciski do wykonywania kluczowych operacji na diagramach:

\begin{itemize}
    \item Add Class - Dodaje nową klasę do diagramu
    \item Add Package - Dodaje nowy pakiet do diagramu
    \item Link Mode - Włącza tryb tworzenia relacji między klasami
    \item Save XMI - Zapisuje diagram do formatu XMI
    \item Load XMI - Wczytuje diagram z pliku XMI
    \item Generate - Generuje kod Python na podstawie diagramu
    \item Clear - Usuwa wszystkie elementy z diagramu
\end{itemize}

\subsection{Widok Drzewa}

Widok drzewa wyświetla pełną hierarchię struktury projektu:

\begin{itemize}
    \item Pakiety pojawują się jako węzły nadrzędne (obsługuje wielopoziomowe zagnieżdżenie)
    \item Klasy wyświetlane są jako węzły podrzędne w odpowiednich pakietach
    \item Relacje między klasami umieszczane są w dedykowanej sekcji
    \item Klikając na element w drzewie, automatycznie zaznaczasz go na diagramie
\end{itemize}

\section{Tworzenie Diagramu}

\subsection{Dodawanie Klasy do Diagramu}

Aby dodać nową klasę do diagramu, wykonaj następujące kroki:

\begin{enumerate}
    \item Kliknij przycisk \textbf{Add Class} na pasku narzędzi
    \item Nowa klasa pojawi się w centralnej części obszaru roboczego
    \item Przeciągnij klasę na wybrane miejsce w diagramie
    \item Kliknij na klasę, aby ją zaznaczyć i otworzyć panel edycji
    \item W panelu edycji wprowadź:
    \begin{itemize}
        \item Nazwę klasy
        \item Atrybuty (opcjonalnie)
        \item Operacje metod (opcjonalnie)
        \item Pakiet, do którego klasa powinna należeć (opcjonalnie)
    \end{itemize}
\end{enumerate}

\subsection{Organizacja Klas w Pakiety}

Pakiety umożliwiają logiczne pogrupowanie powiązanych klas. Aby pracować z pakietami:

\begin{enumerate}
    \item Kliknij przycisk \textbf{Add Package} na pasku narzędzi
    \item Nowy pakiet pojawi się na kanwie jako kontener
    \item Umieść pakiet w wybranym miejscu, przeciągając go
    \item Przeciągnij klasy do wnętrza pakietu, aby je do niego przypisać
    \item W panelu edycji nadaj pakietowi opisową nazwę
\end{enumerate}

Możesz tworzyć hierarchiczne struktury pakietów, przeciągając jeden pakiet do innego. Klasy są automatycznie przypisywane do najbardziej zagnieżdżonego pakietu, w którym się znajdują.

\subsubsection{Tworzenie Relacji między Klasami}

Relacje definiują powiązania między klasami. Aby utworzyć relację:

\begin{enumerate}
    \item Kliknij przycisk \textbf{Link Mode} na pasku narzędzi
    \item Z listy rozwijanej wybierz typ relacji (np. dziedziczenie, kompozycja)
    \item Kliknij na klasę źródłową (klasa klient)
    \item Następnie kliknij na klasę docelową (klasa dostawca)
    \item Relacja zostanie wizualnie wyświetlona jako linia łącząca obie klasy
\end{enumerate}

\small{\slshape{Relacje mają kierunek - upewnij się, że klikasz klasy w prawidłowej kolejności}}

\subsubsection{Edycja Elementów Diagramu}

Aby zmodyfikować właściwości elementu:

\begin{enumerate}
    \item Kliknij na element (klasę lub pakiet), aby go zaznaczyć
    \item W odpowiednim panelu edycji zmień wymagane pola
    \item Zmiany są zapisywane automatycznie
\end{enumerate}

\subsubsection{Usuwanie Elementów z Diagramu}

Aby usunąć element:

\begin{enumerate}
    \item Zaznacz element klikając na niego
    \item Kliknij przycisk \textbf{Delete} w panelu edycji
    \item Element zostanie usunięty z diagramu
\end{enumerate}

\small{\slshape{Usunięcie klasy automatycznie usuwa wszystkie relacje, w których ta klasa uczestniczy.}}

\section{Zarządzanie Diagramami}

\subsubsection{Eksportowanie Diagramu do Formatu XMI}

Format XMI (XML Metadata Interchange) to standardowy format wymiany diagramów UML. Aby zapisać diagram:

\begin{enumerate}
    \item Kliknij przycisk \textbf{Save XMI} na pasku narzędzi
    \item Plik XMI zostanie automatycznie pobrany do folderu pobierania
    \item Plik zawiera pełną reprezentację diagramu, w tym pakiety, klasy, relacje oraz strukturę zagnieżdżeń
\end{enumerate}

\subsubsection{Importowanie Diagramu z Pliku XMI}

Aby załadować poprzednio zapisany diagram:

\begin{enumerate}
    \item Kliknij przycisk \textbf{Load XMI} na pasku narzędzi
    \item Wybierz plik XMI ze swojego komputera
    \item Diagram zostanie wczytany i wyświetlony na kanwie
    \item Wszystkie elementy automatycznie dostosowują swoją pozycję, aby uniknąć nakładania się
    \item Zagnieżdżone pakiety i klasy są poprawnie odtworzyme
\end{enumerate}

\small{\slshape{Wczytanie nowego diagramu spowoduje zastąpienie obecnego diagramu. Jeśli chcesz zachować bieżący diagram, wcześniej go zapisz.}}

\section{Generowanie Kodu Python}

\subsection{Przygotowanie Projektu}

Przed generowaniem kodu upewnij się, że Twój diagram spełnia następujące warunki:

\begin{itemize}
    \item Wszystkie klasy posiadają przypisane nazwy
    \item Atrybuty i operacje są poprawnie i kompletnie zdefiniowane
    \item Relacje między klasami są prawidłowo utworzone
    \item Klasy są przypisane do odpowiednich pakietów (zalecane, ale opcjonalne)
\end{itemize}

\subsection{Proces Generowania}

Aby wygenerować kod Python:

\begin{enumerate}
    \item Kliknij przycisk \textbf{Generate} na pasku narzędzi
    \item System automatycznie:
    \begin{itemize}
       \item Eksportuje diagram do formatu XMI
       \item Przesyła plik do serwera przetwarzającego
       \item Generuje pełny kod Python z dokumentacją
       \item Pakuje projekt w archiwum ZIP
    \end{itemize}
    \item Gotowe archiwum ZIP pobiera się automatycznie do folderu pobierania
\end{enumerate}

\subsection{Mapowanie Typów Danych}

Aplikacja automatycznie konwertuje typy danych UML na odpowiadające im typy Python:

\begin{table}[h!]
    \centering
    \footnotesize
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Typ UML} &
        \textbf{Typ Python} \\ \hline
        \texttt{String} &
        \texttt{str} \\ \hline
        \texttt{Integer} &
        \texttt{int} \\ \hline
        \texttt{Float} &
        \texttt{float} \\ \hline
    \end{tabular}
    \caption{Mapowanie typów UML na typy w Pythonie}
    \label{tab:instrukcja_uml_mapowanie_typow}
\end{table}

Nazwy klas w typach danych są traktowane jako referencje do klas użytkownika i nie podlegają transformacji.

\section{Rozwiązywanie Problemów}

\subsection{Kod nie został wygenerowany}

Jeśli kod Python nie generuje się prawidłowo, sprawdź:

\begin{itemize}
    \item Czy wszystkie klasy mają przypisane nazwy
    \item Konsolę przeglądarki w poszukiwaniu błędów JavaScript
    \item Logi serwera w poszukiwaniu błędów parsowania XMI
\end{itemize}

\subsection{Elementy nie są widoczne na kanwie}

Jeśli nie widzisz elementów na diagramie:

\begin{itemize}
    \item Sprawdź, czy elementy nie zostały przypadkowo przesunięte poza widoczny obszar
    \item Przybliż lub oddalź widok za pomocą kółka myszy
    \item Użyj przycisku \textbf{Clear} i zacznij od nowa
    \item Odśwież stronę w przeglądarce
\end{itemize}

W razie dodatkowych pytań lub problemów, sprawdź logi w konsoli przeglądarki, które mogą dostarczyć szczegółowych informacji o błędach.

\chapter{Podsumowanie i wnioski końcowe}

\section{Ocena stopnia realizacji projektu}

Opracowane narzędzie w pełni spełnia założone cele projektu i realizuje wszystkie wymagania funkcjonalne zdefiniowane w początkowych etapach pracy. Przeprowadzona implementacja obejmuje zarówno bibliotekę Pythonową do przetwarzania modeli UML, jak i kompletną aplikację webową umożliwiającą interaktywne tworzenie diagramów klas oraz automatyczne generowanie kodu źródłowego.

W aspekcie funkcjonalnym zrealizowano wszystkie zaplanowane komponenty: parser XMI obsługujący standard 2.1 z pełną obsługą pakietów zagnieżdżonych, relacji międzyklasowych oraz typów danych; generator  koduPython z właściwą mapą typów, wsparciem dla wszystkich sześciu typów relacji UML (asocjacja, agregacja, kompozycja, dziedziczenie, realizacja, zależność) oraz automatycznym zarządzaniem importami; oraz interfejs webowy umożliwiający intuicyjne tworzenie i edycję diagramów w przeglądarce.

Zbudowana architektura oparta na wzorcu trójwarstwowym zapewnia czytelność kodu, łatwość testowania oraz możliwość niezależnego wykorzystywania warstwy domenowej w innych projektach. Szczególnie wartościowym aspektem implementacji jest decyzja o udostępnieniu warstwy logiki biznesowej jako osobnego submodułu Git, co umożliwia jej ponowne wykorzystanie w innych aplikacjach bez konieczności stosowania całego systemu.

Testowanie metodą kombinacji testów jednostkowych (pytest) oraz weryfikacji manualnych potwierdziło poprawność działania wszystkich istotnych scenariuszy użycia. Testy jednostkowe obejmujące parsowanie XMI, generowanie struktury projektu, mapowanie importów oraz obsługę relacji przebiegły pomyślnie, wykazując, że implementacja pokrywa główne przypadki użycia aplikacji. Weryfikacja manualna potwierdziła intuicyjność interfejsu użytkownika oraz poprawne renderowanie diagramów UML w formacie SVG.

\section{Ocena realizacji projektu z perspektywy komercyjnej i naukowej}

Z perspektywy komercyjnej i naukowej opracowane narzędzie zapełnia istotną lukę rynkową. W porównaniu do istniejących rozwiązań narzędzie łączy zalety webowych edytorów graficznych (dostępność, brak instalacji, interfejs przyjazny użytkownikowi) z precyzją inżynierską systemów CASE (obsługa standardu XMI, generowanie kodu z semantycznym rozumieniem UML), będąc jednocześnie rozwiązaniem open source dedykowanym ekosystemowi Pythona. Brakujący wcześniej segment narzędzi wspierających Model-Driven Development w Pythonie został wypełniony gotowym do użycia rozwiązaniem.

Wygenerowany kod Python spełnia standardy współczesnego programowania: zawiera type hints zgodne z PEP 484, wykorzystuje idiomatyczne konstrukty Pythona, zachowuje hierarchię pakietów odpowiadającą strukturze UML oraz jest gotowy do bezpośredniego użycia w projektach. Pozwala to na szybkie prototypowanie aplikacji oraz zmniejszenie czasu początkowych etapów wytwarzania oprogramowania.

\section{Możliwości dalszego rozwoju aplikacji}

Opracowane narzędzie stanowi solidną podstawę do dalszego rozszerzania funkcjonalności.
Kierunkami dalszego rozwoju mogą być zarówno rozszerzenia funkcjonalne, jak i usprawnienia techniczne.

\subsection{Rozszerzenia funkcjonalne}

\begin{itemize}
    \item Obsługa dodatkowych typów diagramów UML - Aktualnie aplikacja obsługuje wyłącznie diagramy klas. Naturalne rozszerzenie stanowiłoby dodanie obsługi diagramów sekwencji, aktywności, stanów czy przypadków użycia. Implementacja tych typów diagramów pozwoliłaby na pełną obsługę całego standardu UML i byłaby szczególnie wartościowa dla modelowania zaawansowanych systemów.

    \item Generowanie kodu dla innych języków programowania - Warstwa domenowa została zaprojektowana z myślą o rozszerzalności. Logika parsowania i transformacji modelu jest niezależna od docelowego języka programowania. Dodanie obsługi dla Java, C\#, TypeScript czy Go wymagałoby jedynie implementacji nowych szablonów kodu oraz mapowania typów. Takie podejście znacznie rozszerzyłoby grono potencjalnych użytkowników.

    \item Generowanie logiki biznesowej - Aktualnie system generuje jedynie szkielety metod. Zaawansowaną funkcjonalnością byłoby generowanie pełnej logiki biznesowej na podstawie semantyki definiowanej w diagramach, na przykład automatyczne generowanie getterów/setterów, implementacji interfejsów czy obsługi walidacji. Mogłoby to być wspomagane przez integrację z modelami LLM (Large Language Models), które na podstawie opisu biznesowego w komentarzach mogłyby generować działający kod.

    \item Reverse engineering - generowanie diagramów z kodu - Implementacja analizy istniejącego kodu Python i konwersji go na diagramy UML stanowiłaby pełny cykl Model-Driven Development. Funkcjonalność ta wymagałaby zaawansowanej analizy kodu źródłowego oraz ekstrahowania informacji o klasach, atrybutach, metodach i relacjach.

    \item Walidacja i weryfikacja diagramów - System mógłby sprawdzać poprawność modelu w kontekście najlepszych praktyk projektowania: detekcja cykli w hierarchii dziedziczenia, wskazanie naruszeń zasad SOLID, analiza kompleksowości struktury czy sugestie dotyczące refaktoryzacji.

    \item Wspólne edycje i kontrola wersji - Integracja z systemami kontroli wersji (Git) w celu obsługi wieloosobowych sesji edycji, automatycznego śledzenia zmian modelu i możliwości cofania operacji. Wspólne edycje wymagałyby implementacji mechanizmu konfliktów rozstrzygania zmian oraz synchronizacji stanów między klientami.

    \item Analityka i metryki modelu - System mógłby przygotowywać raporty na temat modelu: liczba klas, głębokość hierarchii dziedziczenia, stopień sprzężenia, złożoność struktury. Metryki te mogłyby być wizualizowane i służyć do identyfikacji potencjalnych problemów architektonicznych.

    \item Integracja z IDE - Rozszerzenie wtyczek dla popularnych edytorów (Visual Studio Code, JetBrains IDE) umożliwiłoby użytkownikom pracę z diagramami bez opuszczania ich głównego środowiska programistycznego.

    \item Generacja dokumentacji - Automatyczne tworzenie dokumentacji technicznej na podstawie modelu UML: diagramy, opisy architektoniczne, słowniki konceptów, mapy zależności modułów.
\end{itemize}

\subsection{Prace badawcze}

\begin{itemize}
    \item Empiryczna ocena efektywności MDD w Pythonie - Przeprowadzenie badań z udziałem programistów w celu zmierzenia rzeczywistego przyspieszenia wytwarzania oprogramowania przy zastosowaniu narzędzia oraz jakości wygenerowanego kodu.

    \item Porównanie z innymi podejściami - Analiza różnic między generowaniem kodu z modeli a organicznym rozwojem kodu bez fazy modelowania pod kątem długoterminowej utrzymywalności i elastyczności systemów.
\end{itemize}

\begin{thebibliography}{13}

    \bibitem{omg_uml} Object Management Group, \emph{OMG Unified Modeling Language (UML) Version 2.5.1}, formal/17-12-05, \url{https://www.omg.org/spec/UML/2.5.1/}

    \bibitem{omg_xmi} Object Management Group, \emph{XML Metadata Interchange (XMI) Version 2.1.1}, formal/12-05-01, \url{https://www.omg.org/spec/XMI/2.1.1/}

    \bibitem{france_mdd} France R., Rumpe B., \emph{Model-driven Development of complex Software: A Research Roadmap}, Future of Software Engineering Research, ACM, 2010

    \bibitem{pep484} Python Software Foundation, \emph{typing -- Support for type hints}, Python 3.12 Documentation, \url{https://docs.python.org/3/library/typing.html}

    \bibitem{fastapi} Tiobe Software, \emph{FastAPI Documentation: High-Performance Python Web Framework}, \url{https://fastapi.tiangolo.com/}

    \bibitem{enterprise_arch} Sparx Systems, \emph{Enterprise Architect User Guide v16}, Sparx Systems Pty Ltd, \url{https://sparxsystems.com/enterprise_architect_user_guide/}

    \bibitem{visual_paradigm} Visual Paradigm International, \emph{Visual Paradigm User Manual}, \url{https://www.visual-paradigm.com/support/documents/vpuserguide/}

    \bibitem{staruml} Plastic Software Inc., \emph{StarUML Documentation v6.0}, \url{https://docs.staruml.io/}

    \bibitem{plantuml} PlantUML Team, \emph{PlantUML Documentation}, \url{https://plantuml.com/}

    \bibitem{drawio} JGraph Ltd., \emph{diagrams.net (draw.io) Technical Documentation}, \url{https://www.diagrams.net/doc/}

    \bibitem{clean_arch} Martin R.C., \emph{Clean Architecture: A Craftsman's Guide to Software Structure and Design}

    \bibitem{pytest_okken} Okken B., \emph{Python Testing with pytest, Second Edition}, Pragmatic Bookshelf, 2022

\end{thebibliography}

\end{document}