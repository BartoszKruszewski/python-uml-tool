\documentclass[polish,inz,longabstract]{iithesis}

\usepackage[utf8]{inputenc}
\usepackage{lipsum}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{url}


\polishtitle{
    Narzędzie do automatycznego generowania kodu Python na podstawie diagramów UML
}
\englishtitle{
    Tool for automatic Python code generation from UML diagrams
}

\polishabstract{
    Celem pracy jest opracowanie narzędzia automatyzującego proces tworzenia struktury projektów w języku Python na podstawie diagramów UML. Praca została podzielona na dwa etapy. W części analitycznej dokonano przeglądu dostępnych rozwiązań, identyfikując lukę w narzędziach łączących specyfikę środowiska Python z prostą obsługą. Na tej podstawie sformułowano szczegółowe wymagania funkcjonalne i niefunkcjonalne systemu. Część projektowa obejmuje implementację aplikacji w architekturze trójwarstwowej. Przedstawiono autorski algorytm generowania kodu z plików XMI, warstwę serwerową opartą na frameworku FastAPI oraz interfejs użytkownika umożliwiający edycję diagramów. Skuteczność rozwiązania została zweryfikowana poprzez serię testów funkcjonalnych i wydajnościowych.
}

\englishabstract{
    The primary objective of this thesis is the development of a tool designed to automate the process of creating Python project structures based on UML diagrams. The study is organized into two distinct phases. The analytical section provides a review of currently available solutions, identifying a gap in tools that effectively combine the specific characteristics of the Python environment with ease of operation. Consequently, detailed functional and non-functional requirements for the system were formulated. The design section encompasses the implementation of the application utilizing a three-tier architecture. The thesis presents a custom algorithm for generating code from XMI files, a server layer built upon the FastAPI framework, and a user interface facilitating diagram editing. The efficacy of the proposed solution was validated through a comprehensive series of functional and performance tests.
}

\author{Bartosz Kruszewski}

\advisor{dr Marcin Młotkowski}

\transcriptnum {337568}
\advisorgen    {dr Marcin Młotkowski}

\begin{document}

\chapter{Wstęp}

\section{Wprowadzenie do tematyki}

Współczesna inżynieria oprogramowania coraz bardziej koncentruje się na automatyzacji procesów wytwórczych, obejmującej zarządzanie infrastrukturą oraz generowanie kodu źródłowego. Wraz ze wzrostem złożoności systemów informatycznych, kluczowym elementem procesu deweloperskiego stało się modelowanie, a standardem w tej dziedzinie jest język UML (Unified Modeling Language) \cite{omg_uml}. UML umożliwia wizualne przedstawienie architektury systemu przed rozpoczęciem implementacji.

W klasycznym podejściu często występuje rozdźwięk między modelem projektowym a finalnym kodem. Ręczne odwzorowanie diagramów klas na strukturę plików i definicje obiektów jest czasochłonne, powtarzalne i podatne na błędy. Format XMI (XML Metadata Interchange) \cite{omg_xmi} odgrywa kluczową rolę w interoperacyjności narzędzi modelujących, umożliwiając wymianę metadanych modeli UML między różnymi środowiskami.

\section{Uzasadnienie wyboru tematu}

Wybór tematu wynika z obserwacji powszechnego problemu w procesie wytwarzania oprogramowania — braku spójności między fazą projektowania a fazą implementacji. Diagramy UML, traktowane jako fundament architektury, szybko stają się nieaktualne wobec rzeczywistego kodu. Ręczna translacja modeli na kod jest żmudna, mechaniczna i obarczona ryzykiem błędów, co prowadzi do powstawania długu technologicznego już na starcie projektu.

Decyzja o stworzeniu narzędzia automatyzującego ten proces wynika z chęci rozwiązania tego problemu poprzez praktyczne zastosowanie podejścia Model-Driven Development (MDD) \cite{france_mdd}. Komercyjne środowiska CASE (Computer-Aided Software Engineering), takie jak Enterprise Architect czy Visual Paradigm, są często drogie, „ciężkie” oraz oparte na zamkniętym ekosystemie. Istnieje zatem nisza na lekkie, dostępne przez przeglądarkę rozwiązania typu open source, które obniżają próg wejścia do profesjonalnego modelowania systemów.

Projekt odpowiada na rosnącą popularność języka Python w budowaniu złożonych systemów backendowych. W przeciwieństwie do języków silnie typowanych, takich jak Java czy C\#, gdzie generowanie kodu z UML jest standardem, w ekosystemie Pythona brakuje nowoczesnych narzędzi łączących elastyczność języka ze sztywnymi regułami architektonicznymi UML. Stworzenie dedykowanego parsera formatu XMI dla Pythona pozwala na wypełnienie tej luki.

Z perspektywy inżynierskiej, realizacja projektu pozwala pogłębić wiedzę na styku inżynierii oprogramowania, modelowania UML, implementacji parserów struktur danych (XML/XMI) oraz projektowania interfejsów API i aplikacji webowych. Praca umożliwia praktyczne wykorzystanie nowoczesnych rozwiązań full-stack, łącząc teoretyczne aspekty kompilacji i generowania kodu z wyzwaniami współczesnego programowania.

\section{Cel pracy}

Celem pracy jest opracowanie kompleksowego narzędzia wspomagającego proces wytwarzania oprogramowania, umożliwiającego automatyczne generowanie struktury aplikacji w języku Python na podstawie diagramów klas UML. Realizacja celu obejmuje opracowanie dwóch kluczowych komponentów:
\begin{itemize}
    \item Biblioteki Pythonowej służącej do parsowania plików XMI, reprezentujących modele UML, oraz generowania fizycznej struktury projektu: katalogów, plików modułów, definicji klas, atrybutów, metod i relacji. Biblioteka ma zapewniać elastyczność i łatwość integracji z różnymi środowiskami deweloperskimi.

    \item Aplikacji webowej stanowiącej interaktywny edytor diagramów UML, umożliwiający użytkownikowi tworzenie, modyfikowanie i eksportowanie modeli bezpośrednio w przeglądarce. Aplikacja zapewnia wygodny interfejs graficzny oraz komunikację z backendem, który odpowiada za przetworzenie modelu i wygenerowanie kodu źródłowego.
\end{itemize}
Ostatecznym efektem pracy ma być system umożliwiający szybkie prototypowanie aplikacji, zapewniający zgodność między modelem architektonicznym a kodem źródłowym oraz wspierający standaryzację i automatyzację początkowych etapów tworzenia oprogramowania.

\section{Zakres pracy}

Zakres pracy obejmuje projektowanie, implementację oraz testowanie poszczególnych komponentów systemu:
\begin{itemize}
    \item Analizę standardu XMI oraz sposób reprezentacji diagramów klas UML w formacie XML.

    \item Implementację parsera plików XMI w języku Python, wykorzystującego wyłącznie standardowe biblioteki.

    \item Projekt i implementację logiki generowania szkieletu projektu w języku Python, obejmującą tworzenie katalogów, plików modułów, definicji klas, atrybutów, metod oraz relacji dziedziczenia i asocjacji.

    \item Implementację backendu aplikacji webowej w oparciu o framework FastAPI\cite{fastapi}, zapewniającego interfejs API do obsługi żądań generowania kodu oraz eksportu projektu.

    \item Implementację frontendu aplikacji, umożliwiającego interaktywne tworzenie i edycję diagramów klas UML.

    \item Integrację frontendu z backendem poprzez REST API oraz zapewnienie możliwości eksportu modelu w formacie XMI.

    \item Testowanie funkcjonalności generatora kodu oraz aplikacji webowej na wybranych przykładach diagramów UML.

    \item Dokumentację rozwiązania oraz przygotowanie przykładowych przypadków użycia.
\end{itemize}
Praca nie obejmuje implementacji generowania pełnej logiki biznesowej metod (ciała funkcji), a jedynie ich sygnatur oraz struktury architektonicznej wynikającej z modelu UML.

\section{Krótki opis struktury pracy}

Praca została podzielona na dwa główne etapy: analityczny i projektowy.

Etap analityczny (rozdziały 1-2) obejmuje przegląd literatury i istniejących rozwiązań CASE, identyfikację luk rynkowych oraz sformułowanie wymagań funkcjonalnych i niefunkcjonalnych systemu.

Etap projektowy (rozdziały 3-5) opisuje architekturę trójwarstwową aplikacji, implementację kluczowych modułów (parser XMI, generator kodu Python, frontend JS), testy jednostkowe (pytest) oraz instrukcję obsługi.

Zakończenie (rozdział 6) zawiera podsumowanie, ocenę realizacji celów oraz perspektywy rozwoju (obsługa innych diagramów UML, języków programowania).

\chapter{Analiza dziedziny i przegląd narzędzi}

\section{Opis problemu}

W procesie wytwarzania oprogramowania programiści często poświęcają dużo czasu na ręczne przygotowanie struktury projektu: tworzenie katalogów, plików, klas i ich zależności. W przypadku dużych systemów, zwłaszcza modelowanych za pomocą UML, ten etap wiąże się z ryzykiem błędów, niespójności między modelem a kodem oraz wydłużeniem czasu rozpoczęcia właściwej implementacji.

W praktyce, wiele zespołów napotyka trudności z utrzymaniem zgodności architektury (UML) z rzeczywistym kodem. Ręczne tworzenie struktury prowadzi do powstawania „długów technologicznych” - model szybko staje się nieaktualny, a zmiany wymagają wielokrotnego ręcznego aktualizowania kodu. Brak standaryzacji utrudnia pracę zespołową oraz automatyzację testów i integracji ciągłej.

Istniejące narzędzia CASE generują kod z UML, ale są często kosztowne, wymagają instalacji ciężkich aplikacji desktopowych i nie są elastyczne. Brakuje lekkich, otwartych rozwiązań umożliwiających szybkie prototypowanie, automatyzację tworzenia struktury projektu oraz ciągłą synchronizację modelu z kodem.

Celem projektu jest eliminacja tych problemów poprzez stworzenie lekkiego, webowego narzędzia do szybkiego i spójnego generowania szkieletu aplikacji Pythonowej na podstawie diagramów UML, co przekłada się na większą efektywność, mniejszą liczbę błędów i lepszą standaryzację architektury projektów.

\section{Przegląd istniejących, konkurencyjnych rozwiązań}

Rynek narzędzi wspierających modelowanie w języku UML jest silnie spolaryzowany. Z jednej strony dominują rozbudowane, komercyjne systemy CASE, z drugiej - proste edytory graficzne dostępne przez przeglądarkę. Analiza dostępnych rozwiązań pozwala wyodrębnić cztery główne grupy narzędzi, z których każda posiada istotne ograniczenia w kontekście szybkiego prototypowania aplikacji Pythonowych.

Pierwszą grupę stanowią zaawansowane środowiska CASE, takie jak Enterprise Architect \cite{enterprise_arch} czy Visual Paradigm \cite{visual_paradigm}. Są to kompletne platformy inżynierskie oferujące pełną obsługę standardu XMI, inżynierię zwrotną oraz wbudowane generatory kodu. Ich główną wadą jest jednak "ciężkość" (wymóg instalacji desktopowej), wysoki koszt licencji oraz wysoki próg wejścia wynikający ze skomplikowanego interfejsu. Są to narzędzia dedykowane dla architektów korporacyjnych, a nie dla zwinnych zespołów deweloperskich.

Drugą kategorię tworzą lekkie narzędzia desktopowe, reprezentowane przez StarUML \cite{staruml}. Oferują one znacznie lepszy UX niż systemy korporacyjne, jednak ich funkcjonalność w zakresie generowania kodu (szczególnie dla Pythona) opiera się na wtyczkach tworzonych przez społeczność, które często są nieaktualne lub porzucane. Ponadto, wciąż wymagają one instalacji lokalnej, co utrudnia pracę w chmurze.

Trzecią grupą są webowe edytory graficzne, takie jak draw.io (diagrams.net) \cite{drawio}. Cieszą się one ogromną popularnością ze względu na darmowy dostęp i brak konieczności instalacji. Są to jednak narzędzia stricte do rysowania - nie posiadają semantycznego rozumienia obiektów UML. Traktują diagram jako zbiór kształtów, a nie strukturę klas, co w połączeniu z brakiem obsługi formatu XMI całkowicie wyklucza je z procesów automatycznego generowania kodu.

Czwartą grupę stanowią narzędzia typu "Code-as-Diagram", np. PlantUML \cite{plantuml}. Choć są one standardem w dokumentowaniu kodu (model Open Source), nie służą do modelowania architektury w rozumieniu MDD. Nie przechowują one modelu w uniwersalnym formacie metadanych, lecz jedynie renderują obraz na podstawie tekstu, co uniemożliwia dwukierunkową synchronizację z kodem.

\section{Analiza ich wad i zalet}

\begin{table}[h!]
    \centering
    \footnotesize
    \begin{tabular}{|l|l|l|l|l|l|}
        \hline
        \textbf{Narzędzie} & 
        \textbf{Kategoria} & 
        \textbf{Platforma} & 
        \textbf{Licencja} & 
        \textbf{XMI} & 
        \textbf{Python} \\ 
        \hline
        Enterprise Architect & 
        Zaawansowane & 
        Desktop & 
        Komercyjna & 
        Pełne & 
        Tak \\ 
        \hline
        Visual Paradigm & 
        Zaawansowane & 
        Desktop & 
        Subskrypcja & 
        Pełne & 
        Tak \\ 
        \hline
        StarUML & 
        Lekkie & 
        Desktop & 
        Komercyjna & 
        Częściowe & 
        Częściowo \\ 
        \hline
        PlantUML & 
        Code-as-Diagram & 
        IDE/CLI & 
        Open Source & 
        Brak & 
        Brak \\ 
        \hline
        draw.io & 
        Edytor graficzny & 
        Web & 
        Darmowa & 
        Brak & 
        Brak \\ 
        \hline
    \end{tabular}
    \caption{Porównanie wybranych narzędzi CASE i UML}
    \label{tab:narzedzia_case}
\end{table}


Analiza wykazuje wyraźną lukę rynkową. Brakuje narzędzia, które łączyłoby zalety edytorów webowych (dostępność, brak instalacji) z inżynierską precyzją systemów CASE (obsługa XMI, generowanie kodu), będąc jednocześnie rozwiązaniem Open Source dedykowanym specyfice języka Python. Projektowane rozwiązanie ma na celu wypełnienie tej niszy.

\chapter{Analiza wymagań}

\section{Wymagania funkcjonalne}

\subsection{Tworzenie i edycja diagramów klas UML}

\begin{enumerate}[label=\textbf{WF-\arabic*}, leftmargin=*, align=left, font=\bfseries, labelsep=1em]

\item\label{WF-klasa1} System umożliwia użytkownikowi dodawanie klas do diagramu.
\item\label{WF-klasa2} Użytkownik może nadać klasie nazwę.
\item\label{WF-klasa3} Użytkownik może zdefiniować atrybuty klasy (nazwa, typ).
\item\label{WF-klasa4} Użytkownik może zdefiniować operacje klasy (nazwa, parametry, typ zwracany).
\item\label{WF-klasa5} Użytkownik może przypisać klasę do pakietu.

\item\label{WF-pakiet1} System umożliwia użytkownikowi dodawanie pakietów do diagramu.
\item\label{WF-pakiet2} Użytkownik może nadać pakietowi nazwę.
\item\label{WF-pakiet3} System obsługuje zagnieżdżone pakiety.
\item\label{WF-pakiet4} Użytkownik może organizować klasy w pakietach.

\item\label{WF-relacja1} System umożliwia tworzenie relacji między klasami.
\item\label{WF-relacja2} System obsługuje następujące typy relacji: asocjacja, agregacja, kompozycja, dziedziczenie, realizacja, zależność.
\item\label{WF-relacja3} Użytkownik może określić kierunek relacji.

\item\label{WF-edycja1} Użytkownik może modyfikować właściwości klas (nazwa, atrybuty, operacje).
\item\label{WF-edycja2} Użytkownik może modyfikować właściwości pakietów (nazwa).
\item\label{WF-edycja3} Użytkownik może usuwać klasy i pakiety.
\item\label{WF-edycja4} Użytkownik może usuwać relacje.

\item\label{WF-wizualizacja1} System wyświetla diagram w formie graficznej.
\item\label{WF-wizualizacja2} System renderuje klasy jako prostokąty z sekcjami (nazwa, atrybuty, operacje).
\item\label{WF-wizualizacja3} System renderuje pakiety jako kontenery.
\item\label{WF-wizualizacja4} System renderuje relacje jako linie między klasami.
\item\label{WF-wizualizacja5} System wyświetla widok drzewa struktury pakietów i klas.

\end{enumerate}

\subsection{Eksport i import diagramów}

\begin{enumerate}[label=\textbf{WF-\arabic*}, leftmargin=*, align=left, font=\bfseries, labelsep=1em, resume]

\item\label{WF-eksport1} System eksportuje diagram do formatu XMI 2.1.
\item\label{WF-eksport2} Wyeksportowany plik jest zgodny ze standardem OMG.
\item\label{WF-eksport3} Plik XMI zawiera wszystkie elementy diagramu (klasy, pakiety, relacje).

\item\label{WF-import1} System może parsować pliki XMI 2.1.
\item\label{WF-import2} System obsługuje podstawowe elementy XMI (klasy, pakiety, relacje, typy danych).
\item\label{WF-import3} System waliduje poprawność formatu XMI.

\end{enumerate}

\subsection{Generowanie kodu Python}

\begin{enumerate}[label=\textbf{WF-\arabic*}, leftmargin=*, align=left, font=\bfseries, labelsep=1em, resume]

\item\label{WF-struktura1} System generuje strukturę katalogów odpowiadającą pakietom.
\item\label{WF-struktura2} System tworzy pliki \texttt{\_\_init\_\_.py} dla każdego pakietu.
\item\label{WF-struktura3} System generuje pliki \texttt{.py} dla każdej klasy.

\item\label{WF-klasy1} System generuje definicje klas Python z odpowiednią składnią.
\item\label{WF-klasy2} System mapuje atrybuty UML na właściwości klasy.
\item\label{WF-klasy3} System generuje konstruktory z parametrami odpowiadającymi atrybutom.
\item\label{WF-klasy4} System generuje metody odpowiadające operacjom UML.
\item\label{WF-klasy5} System używa type hints \cite{pep484} dla parametrów i zwracanych wartości.

\item\label{WF-typy1} System mapuje standardowe typy UML na typy Python (\texttt{String} $\to$ \texttt{str}, \texttt{Integer} $\to$ \texttt{int}, \texttt{Float} $\to$ \texttt{float}).
\item\label{WF-typy2} System zachowuje nazwy niestandardowych typów (klasy użytkownika).

\item\label{WF-relacje1} System generuje odpowiedni kod dla różnych typów relacji (asocjacja, agregacja, kompozycja, dziedziczenie/realizacja, zależność).

\item\label{WF-importy1} System automatycznie generuje instrukcje \texttt{import} dla używanych klas.
\item\label{WF-importy2} System generuje poprawne ścieżki importu na podstawie struktury pakietów.
\item\label{WF-importy3} System obsługuje importy z zagnieżdżonych pakietów.

\item\label{WF-zip1} System pakuje wygenerowany projekt do archiwum ZIP.
\item\label{WF-zip2} Użytkownik może pobrać archiwum ZIP z wygenerowanym kodem.
\item\label{WF-zip3} Archiwum zawiera kompletną strukturę projektu gotową do użycia.

\item\label{WF-interakcje1} Użytkownik może przeciągać elementy na diagramie.
\item\label{WF-interakcje2} Użytkownik może zaznaczać elementy klikając na nie.
\item\label{WF-interakcje3} Użytkownik może edytować elementy w panelach edycji.
\item\label{WF-interakcje4} Użytkownik może używać widoku drzewa do nawigacji po strukturze.

\item\label{WF-operacje1} Użytkownik może czyścić cały diagram.
\item\label{WF-operacje2} Użytkownik może generować kod z aktualnego diagramu.

\end{enumerate}

\section{Wymagania niefunkcjonalne}

\begin{enumerate}[label=\textbf{WNF-\arabic*}, leftmargin=*, align=left, font=\bfseries, labelsep=1em]

\item\label{WNF-czas1} Generowanie kodu dla projektu z maksymalnie 100 klas powinno zakończyć się w czasie poniżej 5 sekund.
\item\label{WNF-czas2} Renderowanie diagramu powinno być płynne (minimum 30 FPS).
\item\label{WNF-czas3} Interfejs powinien reagować na akcje użytkownika w czasie poniżej 100ms.

\item\label{WNF-skalowalnosc1} System powinien obsługiwać diagramy z maksymalnie 1000 klas.
\item\label{WNF-skalowalnosc2} System powinien obsługiwać zagnieżdżone pakiety do 10 poziomów głębokości.

\item\label{WNF-intuicyjnosc1} Interfejs powinien być intuicyjny i nie wymagać szkolenia.
\item\label{WNF-intuicyjnosc2} Operacje powinny być dostępne w maksymalnie 3 kliknięciach.
\item\label{WNF-intuicyjnosc3} System powinien wyświetlać pomocne etykiety.

\item\label{WNF-dostepnosc1} Aplikacja powinna działać w nowoczesnych przeglądarkach (Chrome, Firefox, Safari, Edge).
\item\label{WNF-dostepnosc2} Interfejs powinien być responsywny i dostosowywać się do różnych rozdzielczości ekranu.

\item\label{WNF-walidacja1} System powinien walidować dane wejściowe (pliki XMI).
\item\label{WNF-walidacja2} System nie powinien tracić danych przy błędach parsowania.

\item\label{WNF-stabilnosc1} System nie powinien zawieszać się podczas normalnego użytkowania.
\item\label{WNF-stabilnosc2} Błędy w jednym komponencie nie powinny wpływać na cały system.

\item\label{WNF-standardy1} System powinien być zgodny ze standardem XMI 2.1.
\item\label{WNF-standardy2} Wygenerowany kod powinien być zgodny z Python 3.11+.
\item\label{WNF-standardy3} System powinien używać type hints zgodnie z PEP 484.

\item\label{WNF-integracja1} System powinien być kompatybilny z innymi narzędziami UML eksportującymi XMI 2.1.
\item\label{WNF-integracja2} Wygenerowany kod powinien być kompatybilny z popularnymi narzędziami Python (pip, setuptools).

\item\label{WNF-modulowosc1} Kod powinien być podzielony na logiczne moduły.
\item\label{WNF-modulowosc2} Warstwa domeny powinna być niezależna od warstwy aplikacji.
\item\label{WNF-modulowosc3} Komponenty powinny być łatwe do testowania.

\item\label{WNF-dokumentacja1} Kod powinien zawierać dokumentację docstring.
\item\label{WNF-dokumentacja2} System powinien mieć dokumentację użytkownika.
\item\label{WNF-dokumentacja3} System powinien mieć dokumentację techniczną dla programistów.

\item\label{WNF-bezpieczenstwo1} System nie przechowuje danych użytkownika po zakończeniu sesji.
\item\label{WNF-bezpieczenstwo2} Pliki tymczasowe są automatycznie usuwane.

\end{enumerate}

\section{Historyjki użytkownika}

\begin{enumerate}[label=\textbf{HU-\arabic*}, leftmargin=*, align=left, font=\bfseries, labelsep=1em]
    \item \textbf{Tworzenie nowego diagramu} \\
    \textbf{Jako} programista Python \textbf{chcę} utworzyć nowy diagram klas UML, \textbf{aby} zaprojektować strukturę mojego projektu przed rozpoczęciem kodowania. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę dodać klasę do diagramu jednym kliknięciem.
        \item Mogę nadać klasie nazwę i zdefiniować jej atrybuty oraz metody.
        \item Widzę diagram wizualnie na ekranie.
    \end{itemize}

    \item \textbf{Organizacja klas w pakietach} \\
    \textbf{Jako} programista Python \textbf{chcę} organizować klasy w pakietach, \textbf{aby} odzwierciedlić strukturę modułów w moim projekcie. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę utworzyć pakiet i nadać mu nazwę.
        \item Mogę przypisać klasy do pakietów.
        \item Mogę tworzyć zagnieżdżone pakiety.
        \item Widzę strukturę pakietów w widoku drzewa.
    \end{itemize}

    \item \textbf{Definiowanie relacji między klasami} \\
    \textbf{Jako} programista Python \textbf{chcę} zdefiniować relacje między klasami, \textbf{aby} zaprojektować zależności i powiązania w moim systemie. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę utworzyć relację między dwiema klasami.
        \item Mogę wybrać typ relacji.
        \item Relacja jest wizualnie wyświetlana na diagramie.
    \end{itemize}

    \item \textbf{Generowanie kodu z diagramu} \\
    \textbf{Jako} programista Python \textbf{chcę} wygenerować kod Python z mojego diagramu, \textbf{aby} szybko stworzyć szkielet projektu bez ręcznego pisania kodu. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę wygenerować kod jednym kliknięciem.
        \item Otrzymuję archiwum ZIP z kompletnym projektem.
        \item Wygenerowany kod zawiera wszystkie klasy z diagramu.
        \item Struktura katalogów odpowiada pakietom w diagramie.
    \end{itemize}

    \item \textbf{Import istniejącego diagramu} \\
    \textbf{Jako} programista Python \textbf{chcę} zaimportować diagram z pliku XMI, \textbf{aby} kontynuować pracę nad diagramem. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę zaimportować plik XMI 2.1.
        \item Wszystkie elementy diagramu są poprawnie załadowane.
        \item Mogę edytować zaimportowany diagram.
    \end{itemize}

    \item \textbf{Edycja właściwości klasy} \\
    \textbf{Jako} programista Python \textbf{chcę} edytować właściwości klasy (atrybuty, metody), \textbf{aby} dostosować klasę do moich potrzeb. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę zaznaczyć klasę i zobaczyć jej właściwości w panelu edycji.
        \item Mogę modyfikować nazwę, atrybuty i operacje klasy.
        \item Zmiany są natychmiast widoczne na diagramie.
    \end{itemize}

    \item \textbf{Eksport diagramu do XMI} \\
    \textbf{Jako} programista Python \textbf{chcę} wyeksportować mój diagram do formatu XMI, \textbf{aby} użyć go w innych narzędziach UML lub zachować jako backup. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę wyeksportować diagram do pliku XMI.
        \item Wyeksportowany plik jest zgodny ze standardem XMI 2.1.
        \item Mogę zaimportować wyeksportowany plik z powrotem.
    \end{itemize}

    \item \textbf{Wizualizacja struktury projektu} \\
    \textbf{Jako} programista Python \textbf{chcę} zobaczyć hierarchiczną strukturę mojego projektu, \textbf{aby} lepiej zrozumieć organizację pakietów i klas. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Widzę drzewo pakietów i klas w osobnym panelu.
        \item Mogę kliknąć element w drzewie, aby go zaznaczyć na diagramie.
        \item Struktura jest aktualizowana w czasie rzeczywistym.
    \end{itemize}

    \item \textbf{Szybkie prototypowanie} \\
    \textbf{Jako} programista Python \textbf{chcę} szybko stworzyć szkielet projektu, \textbf{aby} rozpocząć implementację bez tracenia czasu na ręczne tworzenie plików. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę szybko utworzyć podstawowy diagram z kilkoma klasami.
        \item Generowanie kodu jest szybkie (poniżej 5 sekund dla małych projektów).
        \item Wygenerowany kod jest gotowy do użycia.
    \end{itemize}

    \item \textbf{Nauka UML} \\
    \textbf{Jako} student informatyki \textbf{chcę} używać narzędzia do nauki UML, \textbf{aby} zrozumieć koncepcje modelowania obiektowego. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Interfejs jest intuicyjny i nie wymaga szkolenia.
        \item Mogę eksperymentować z różnymi typami relacji.
        \item Widzę jak diagramy UML przekładają się na kod Python.
    \end{itemize}

    \item \textbf{Współpraca w zespole} \\
    \textbf{Jako} członek zespołu programistów \textbf{chcę} udostępnić mój diagram innym, \textbf{aby} omówić architekturę projektu przed implementacją. \\
    \textit{Kryteria akceptacji:}
    \begin{itemize}
        \item Mogę wyeksportować diagram do standardowego formatu (XMI).
        \item Inni członkowie zespołu mogą zaimportować diagram w swoich narzędziach.
        \item Diagram jest czytelny i zrozumiały dla innych.
    \end{itemize}

\end{enumerate}

\chapter{Architektura i implementacja systemu}

\section{Architektura trójwarstwowa}

System opiera się na architekturze trójwarstwowej, co zapewnia wyraźny podział odpowiedzialności oraz ułatwia rozwój i utrzymanie rozwiązania \cite{clean_arch}. Warstwy komunikują się wyłącznie poprzez zdefiniowane interfejsy, dzięki czemu mogą być rozwijane i testowane niezależnie.

Wyróżnione zostały następujące warstwy:
\begin{itemize}
    \item \textbf{Warstwa prezentacji} -- odpowiada za interaktywny interfejs użytkownika w przeglądarce, renderowanie diagramów UML w formacie SVG oraz obsługę operacji edycyjnych na diagramie. Komunikuje się z backendem wyłącznie przez wywołania HTTP do REST API, przekazując pliki XMI oraz odbierając wygenerowane archiwa ZIP z projektem w języku Python.
    \item \textbf{Warstwa aplikacji} -- udostępnia REST API oparte na frameworku FastAPI, które obsługuje żądania HTTP, wykonuje walidację danych oraz koordynuje przepływ informacji pomiędzy frontendem a logiką domenową. Jej zadaniem jest orkiestracja procesu: od przyjęcia pliku XMI, przez jego przetworzenie, aż po przygotowanie archiwum z wygenerowanym projektem.
    \item \textbf{Warstwa domeny} -- realizuje właściwą logikę biznesową związaną z przetwarzaniem modeli UML. Odpowiada za parsowanie struktury XMI, odwzorowanie relacji pomiędzy elementami modelu oraz generowanie struktury katalogów i plików w języku Python. Warstwa ta pozostaje niezależna od technologii sieciowej i może być wykorzystywana jako samodzielna biblioteka.
\end{itemize}

Komunikacja między warstwami ma charakter kaskadowy: warstwa prezentacji wysyła żądanie HTTP do warstwy aplikacji, która z kolei wywołuje funkcje warstwy domenowej w celu przetworzenia danych i wygenerowania projektu. Wynikowe archiwum ZIP wraca następnie przez warstwę aplikacji do warstwy prezentacji, umożliwiając użytkownikowi jego pobranie bezpośrednio z interfejsu przeglądarki.

\section{Implementacja warstw}

W dalszej części przedstawiono implementację poszczególnych warstw, opisując użyte technologie programistyczne oraz strukturę katalogów źródłowych, odnosząc się do wcześniej zdefiniowanych wymagań funkcjonalnych i niefunkcjonalnych. Szczegółowe zadania modułów opisano w komentarzach kodu źródłowego.

\subsection{Warstwa domeny}

Warstwa domeny została zaimplementowana w języku Python z wykorzystaniem wyłącznie bibliotek standardowych, co minimalizuje zależności zewnętrzne i ułatwia ponowne wykorzystanie tego modułu w innych projektach (\ref{WF-struktura1}, \ref{WF-struktura2}, \ref{WF-struktura3}, \ref{WF-klasy1}, \ref{WF-typy1}). Kod warstwy domenowej jest zorganizowany jako submoduł w katalogu \path{domain/src/project_generator/}, zawierając moduły odpowiedzialne m.in.\ za wewnętrzną reprezentację modelu UML, parsowanie plików XMI (\ref{WF-import1}, \ref{WF-import2}, \ref{WF-import3}) oraz generowanie struktury katalogów i plików projektu Python.

Warstwa ta obsługuje podstawowe relacje UML, takie jak asocjacje, agregacje, kompozycje, dziedziczenie, realizacje i zależności (\ref{WF-relacje1}), mapując je na idiomatyczne konstrukcje języka Python w generowanym projekcie (\ref{WNF-skalowalnosc1}). Proces przetwarzania obejmuje konwersję modelu UML z formatu XMI na wewnętrzną reprezentację, a następnie utworzenie finalnej struktury modułów i pakietów w wygenerowanym projekcie (\ref{WNF-standardy1}).

\subsection{Warstwa aplikacji}

Warstwa aplikacji obejmuje główne pliki Python projektu znajdujące się w katalogu \path{/src/uml_tool/} i została zbudowana w oparciu o framework FastAPI \cite{fastapi}. FastAPI charakteryzuje się wysoką wydajnością oraz prostą definicją endpointów, co czyni go dobrym wyborem dla lekkich serwisów udostępniających REST API \cite{fastapi}. W porównaniu z alternatywami takimi jak Flask czy Django oferuje on minimalistyczne podejście przy zachowaniu wysokiej wydajności, kosztem mniejszej liczby wbudowanych funkcjonalności, co jest wystarczające dla potrzeb prezentowanej aplikacji (\ref{WNF-czas1}).

Warstwa aplikacji wystawia endpoint serwujący interfejs użytkownika oraz endpoint odpowiedzialny za przyjmowanie plików XMI i zwracanie wygenerowanego projektu jako archiwum ZIP (\ref{WF-zip1}, \ref{WF-zip2}). Jej logika obejmuje walidację przesyłanych plików (\ref{WNF-walidacja1}), wywołanie odpowiednich funkcji warstwy domenowej, obsługę błędów na każdym etapie procesu (\ref{WNF-stabilnosc1}) oraz przygotowanie jednolitego formatu odpowiedzi dla klienta.

\subsection{Warstwa prezentacji}

Warstwa prezentacji została zaimplementowana z wykorzystaniem HTML, CSS, JavaScript oraz biblioteki Bootstrap, bez użycia dedykowanego frameworka frontendowego (\ref{WNF-intuicyjnosc1}, \ref{WNF-dostepnosc1}). Taki wybór wynika z relatywnie prostej logiki interfejsu, w którym dominują aspekty wizualne i operacje na diagramie (\ref{WF-klasa1}, \ref{WF-klasa2}, \ref{WF-pakiet1}, \ref{WF-wizualizacja1}), a wprowadzenie cięższego frameworka (np.\ React) nie przyniosłoby proporcjonalnych korzyści w stosunku do zwiększonej złożoności rozwiązania. Kod frontendu zorganizowano w katalogu \path{src/static/}, dzieląc go na moduły odpowiedzialne za zarządzanie stanem diagramu, renderowanie SVG, obsługę interakcji użytkownika (\ref{WF-interakcje1}) oraz wymianę danych z backendem.

Warstwa prezentacji umożliwia użytkownikowi tworzenie i edycję diagramów UML, zarządza stanem elementów (klasy, pakiety, relacje) oraz obsługuje eksport diagramu do formatu XMI (\ref{WF-eksport1}), który jest następnie przekazywany do warstwy aplikacji. Dodatkowo warstwa ta udostępnia mechanizmy importu istniejących plików XMI oraz pozwala użytkownikowi pobrać wygenerowane archiwum ZIP z projektem w języku Python (\ref{WF-operacje1}, \ref{WF-operacje2}).

\section{Narzędzia i środowisko}

Do zarządzania kodem źródłowym wykorzystano system kontroli wersji Git (\ref{WNF-modulowosc1}). Ze względu na modularność warstwy domenowej, która może być autonomicznie wykorzystywana w innych projektach (\ref{WNF-modulowosc2}), repozytorium zostało podzielone na główne repozytorium aplikacji oraz submoduł zawierający warstwę domenową, oba hostowane na platformie GitHub.

Zależności zewnętrzne zarządzane są przy pomocy wirtualnych środowisk \texttt{venv} oraz narzędzia \texttt{pip}. Konfiguracja pakietów oraz minimalny zestaw wymaganych bibliotek zostały zdefiniowane w pliku \texttt{pyproject.toml}, co zapewnia pełną reprodukowalność środowiska deweloperskiego (\ref{WNF-integracja2}).

Testy automatyczne dla warstwy domenowej oraz wybranych elementów warstwy aplikacji zostały przygotowane z użyciem frameworka \texttt{pytest} \cite{pytest_okken}, który stanowi standard w nowoczesnych projektach Python (\ref{WNF-modulowosc3}).

\section{Przepływ danych}

Cały proces generowania kodu przebiega zgodnie z następującą sekwencją kroków:
\begin{enumerate}
    \item Użytkownik tworzy lub edytuje diagram UML w interfejsie przeglądarkowym.
    \item Diagram jest eksportowany do formatu XMI i wysyłany do backendu za pomocą żądania HTTP do endpointu REST API.
    \item Warstwa aplikacji waliduje przesłany plik, przekazuje go do warstwy domeny i inicjuje proces parsowania modelu UML.
    \item Warstwa domeny przekształca strukturę XMI na wewnętrzną reprezentację, generuje strukturę katalogów oraz pliki źródłowe w języku Python.
    \item Warstwa aplikacji pakuje wynikowy projekt do archiwum ZIP i zwraca go w odpowiedzi HTTP.
    \item Warstwa prezentacji udostępnia użytkownikowi możliwość pobrania wygenerowanego projektu.
\end{enumerate}

\chapter{Testowanie i weryfikacja}

\section{Zakres testowania}

Testowanie obejmowało kluczowe aspekty funkcjonalne aplikacji, w szczególności przetwarzanie danych XMI, generowanie kodu oraz mapowanie struktury projektów. Weryfikacji poddano następujące elementy: parsowanie pakietów, klas i relacji z plików XMI, generowanie kodu Python z zachowaniem hierarchii pakietów, prawidłowe mapowanie importów dla zagnieżdżonych struktur pakietów oraz obsługę wszystkich typów relacji UML. Dodatkowo przeprowadzono weryfikację poprawności generowania plików projektu i inicjalizacji pakietów w wygenerowanym kodzie.

\section{Testy jednostkowe}

Zestaw testów jednostkowych implementowanych z wykorzystaniem frameworka pytest obejmował cztery główne komponenty aplikacji:

\begin{itemize}
    \item ImportMapping - Weryfikacja mechanizmu mapowania ścieżek importów dla klas w zagnieżdżonych pakietach, w tym obsługę scenariuszy z wieloma klasami w jednym pakiecie, klasami rozproszonymi w różnych pakietach oraz przypadkami zawierającymi brakujące klasy.

    \item ProjectGenerator - Testowanie procesu tworzenia struktury katalogów dla projektów o różnym stopniu złożoności: pakiety puste, struktury płaskie oraz zagnieżdżone hierarchie pakietów, z weryfikacją obecności plików i prawidłowego generowania plików klas ze skeletami kodu.

    \item TemplateManager - Walidacja poprawności generowania definicji klas z właściwościami i operacjami, a także obsługa wszystkich typów relacji UML (asocjacja, agregacja, kompozycja, dziedziczenie, realizacja, zależność) w generowanym kodzie.

    \item XmiParser - Testowanie parsowania plików XMI o różnych strukturach, w tym pakiety puste i zagnieżdżone, klasy bez pól i metod, wszystkie typy relacji, właściwości i operacje bez jawnie zdefiniowanych typów oraz walidacja obsługi błędnego lub niekompletnego XMI.
\end{itemize}

\section{Testy manualne}

Testowanie manualne przeprowadzono w celu weryfikacji aspektów interfejsu użytkownika i wizualizacji, które nie mogą być w pełni ocenione przez testy automatyczne. Obejmowało to: sprawdzenie poprawności eksportu i importu plików XMI poprzez interfejs graficzny oraz weryfikację wizualizacji diagramu UML w formacie SVG, w szczególności poprawne renderowanie relacji między komponentami.

\section{Wnioski z testowania}

Testy jednostkowe wykonane z użyciem pytest przebiegły pomyślnie i wykazały, że implementacja pokrywa główne scenariusze użycia aplikacji: import i przetwarzanie plików XMI, mapowanie struktur pakietów i klas, generowanie hierarchii projektów oraz prawidłową obsługę wszystkich typów relacji UML. Testy manualne potwierdziły intuicyjność interfejsu użytkownika oraz poprawne działanie podstawowych operacji na diagramach.

Przeprowadzone testowanie wykazało, że wszystkie wymagania funkcjonalne zdefiniowane w sekcji historyjek użytkownika zostały spełnione. Aplikacja poprawnie obsługuje eksport i import danych w formacie XMI, zapewnia logiczną organizację pakietów oraz umożliwia definiowanie złożonych relacji między komponentami modelu. Dodatkowo system generuje kod Python zachowujący strukturę diagramu UML, co stanowi zasadniczy cel aplikacji.

\chapter{Instrukcja obsługi}

\section{Wprowadzenie}

Narzędzie UML jest zaawansowaną aplikacją webową do tworzenia diagramów klas UML z możliwością automatycznego generowania kodu Python. Intuicyjny interfejs pozwala użytkownikom na szybkie i efektywne modelowanie systemów informatycznych bez konieczności ręcznego pisania kodu.

\section{Wdrożenie aplikacji}

\subsection{Instalacja zależności}

Przed pierwszym uruchomieniem aplikacji zainstaluj wymagane pakiety:

\begin{lstlisting}[language=Bash]
pip install -e domain
pip install -e .
\end{lstlisting}

\subsection{Uruchamianie serwera}

Aby uruchomić aplikację, wykonaj polecenie:

\begin{lstlisting}[language=Bash]
python run.py
\end{lstlisting}

Aplikacja będzie dostępna w przeglądarce internetowej pod adresem \url{https://localhost:8080}.

\section{Prezentacja interfejsu użytkownika}

Sekcja prezentuje wizualną realizację warstwy prezentacji aplikacji webowej, zbudowanej w technologiach HTML, CSS i JavaScript z renderowaniem diagramów w SVG. Interfejs zapewnia intuicyjną obsługę wszystkich funkcjonalności zdefiniowanych w historyjkach użytkownika.

\subsection{Widok główny aplikacji}
Główny ekran aplikacji udostępnia trzy kluczowe panele: obszar rysowania diagramu, pasek narzędzi oraz hierarchiczne drzewo struktury projektu.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.95\textwidth]{img/main_view.png}
    \caption{Główny widok aplikacji z paskiem narzędzi, obszarem rysowania i drzewem struktury.}
    \label{fig:glowny_widok}
\end{figure}

Pasek narzędzi (dolna część rys. \ref{fig:glowny_widok}) zawiera przyciski do podstawowych operacji: dodawania klas (\emph{Add Class}), pakietów (\emph{Add Package}), tworzenia relacji (\emph{Link Mode}), eksportu/importu XMI oraz generowania kodu (\emph{Generate}). Obszar rysowania wspiera gesty przeciągania, zoom (kółko myszy) i panowanie (spacja + przeciąganie).

\subsection{Tworzenie i edycja elementów}
Interfejs umożliwia definiowanie pełnych klas UML z atrybutami, operacjami i przypisaniem do pakietów poprzez dedykowane panele edycji.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{img/edit_class.png}
    \caption{Panel edycji klasy z zdefiniowanymi atrybutami, operacjami i mapowaniem typów.}
    \label{fig:edycja_klasy}
\end{figure}

Na rys. \ref{fig:edycja_klasy} widoczny jest panel edycji klasy z atrybutami i operacjami.

\subsection{Organizacja w pakietach i relacje}
Pakiety umożliwiają hierarchiczną organizację klas odpowiadającą strukturze modułów Pythona. Relacje między klasami renderowane są jako skierowane linie z odpowiednimi oznaczeniami UML.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.95\textwidth]{img/packages_relations.png}
\caption{Hierarchia pakietów z relacjami}
\label{fig:pakiety_relacje}
\end{figure}

Rysunek \ref{fig:pakiety_relacje} pokazuje zagnieżdżoną strukturę pakietów i relacji.

\section{Omówienie interfejsu}

Interfejs użytkownika podzielony jest na kilka logicznych sekcji:

\begin{table}[h!]
    \centering
    \footnotesize
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Komponent} &
        \textbf{Opis} \\ \hline
        \textbf{Obszar rysowania} &
        Główne pole robocze do tworzenia diagramów \\ \hline
        \textbf{Pasek narzędzi} &
        Przyciski do operacji na diagramach \\ \hline
        \textbf{Widok drzewa} &
        Hierarchiczna struktura pakietów i klas \\ \hline
        \textbf{Panele edycji} &
        Edytory właściwości wybranych elementów \\ \hline
    \end{tabular}
    \caption{Podstawowe komponenty interfejsu aplikacji do edycji diagramów UML}
    \label{tab:intrukcja_uml_komponenty}
\end{table}

\subsection{Obszar rysowania}

Obszar rysowania stanowi główne pole robocze aplikacji, gdzie umieszczone są wszystkie elementy diagramu. W tym obszarze możesz wykonywać poniższe operacje:

Operacje na elementach:
\begin{itemize}
    \item Przesuwanie elementów - Kliknij i przytrzymaj element, następnie przeciągnij go w żądane miejsce
    \item Zaznaczanie - Kliknij na element, aby go zaznaczyć i uaktywnić panel edycji
    \item Przesuwanie widoku - Przeciągnij pusty obszar kanwy lub przytrzymaj klawisz spacji i przeciągnij, aby przesunąć widok
    \item Zmiana skali - Użyj kółka myszy do przybliżania i oddalania widoku
\end{itemize}

\subsection{Pasek narzędzi}

Pasek narzędzi zlokalizowany na dole ekranu zawiera przyciski do wykonywania kluczowych operacji na diagramach:

\begin{itemize}
    \item Add Class - Dodaje nową klasę do diagramu
    \item Add Package - Dodaje nowy pakiet do diagramu
    \item Link Mode - Włącza tryb tworzenia relacji między klasami
    \item Save XMI - Zapisuje diagram do formatu XMI
    \item Load XMI - Wczytuje diagram z pliku XMI
    \item Generate - Generuje kod Python na podstawie diagramu
    \item Clear - Usuwa wszystkie elementy z diagramu
\end{itemize}

\subsection{Widok drzewa}

Widok drzewa wyświetla pełną hierarchię struktury projektu:

\begin{itemize}
    \item Pakiety pojawują się jako węzły nadrzędne (obsługuje wielopoziomowe zagnieżdżenie)
    \item Klasy wyświetlane są jako węzły podrzędne w odpowiednich pakietach
    \item Relacje między klasami umieszczane są w dedykowanej sekcji
    \item Klikając na element w drzewie, automatycznie zaznaczasz go na diagramie
\end{itemize}

\section{Tworzenie diagramu}

\subsection{Dodawanie klasy do diagramu}

Aby dodać nową klasę do diagramu, wykonaj następujące kroki:

\begin{enumerate}
    \item Kliknij przycisk \textbf{Add Class} na pasku narzędzi
    \item Nowa klasa pojawi się w centralnej części obszaru roboczego
    \item Przeciągnij klasę na wybrane miejsce w diagramie
    \item Kliknij na klasę, aby ją zaznaczyć i otworzyć panel edycji
    \item W panelu edycji wprowadź:
    \begin{itemize}
        \item Nazwę klasy
        \item Atrybuty (opcjonalnie)
        \item Operacje metod (opcjonalnie)
        \item Pakiet, do którego klasa powinna należeć (opcjonalnie)
    \end{itemize}
\end{enumerate}

\subsection{Organizacja klas w pakiety}

Pakiety umożliwiają logiczne pogrupowanie powiązanych klas. Aby pracować z pakietami:

\begin{enumerate}
    \item Kliknij przycisk \textbf{Add Package} na pasku narzędzi
    \item Nowy pakiet pojawi się na kanwie jako kontener
    \item Umieść pakiet w wybranym miejscu, przeciągając go
    \item Przeciągnij klasy do wnętrza pakietu, aby je do niego przypisać
    \item W panelu edycji nadaj pakietowi opisową nazwę
\end{enumerate}

Możesz tworzyć hierarchiczne struktury pakietów, przeciągając jeden pakiet do innego. Klasy są automatycznie przypisywane do najbardziej zagnieżdżonego pakietu, w którym się znajdują.

\subsubsection{Tworzenie relacji między klasami}

Relacje definiują powiązania między klasami. Aby utworzyć relację:

\begin{enumerate}
    \item Kliknij przycisk \textbf{Link Mode} na pasku narzędzi
    \item Z listy rozwijanej wybierz typ relacji (np. dziedziczenie, kompozycja)
    \item Kliknij na klasę źródłową (klasa klient)
    \item Następnie kliknij na klasę docelową (klasa dostawca)
    \item Relacja zostanie wizualnie wyświetlona jako linia łącząca obie klasy
\end{enumerate}

\small{\slshape{Relacje mają kierunek - upewnij się, że klikasz klasy w prawidłowej kolejności}}

\subsubsection{Edycja elementów diagramu}

Aby zmodyfikować właściwości elementu:

\begin{enumerate}
    \item Kliknij na element (klasę lub pakiet), aby go zaznaczyć
    \item W odpowiednim panelu edycji zmień wymagane pola
    \item Zmiany są zapisywane automatycznie
\end{enumerate}

\subsubsection{Usuwanie elementów z diagramu}

Aby usunąć element:

\begin{enumerate}
    \item Zaznacz element klikając na niego
    \item Kliknij przycisk \textbf{Delete} w panelu edycji
    \item Element zostanie usunięty z diagramu
\end{enumerate}

\small{\slshape{Usunięcie klasy automatycznie usuwa wszystkie relacje, w których ta klasa uczestniczy.}}

\section{Zarządzanie diagramami}

\subsubsection{Eksportowanie diagramu do formatu XMI}

Format XMI (XML Metadata Interchange) to standardowy format wymiany diagramów UML. Aby zapisać diagram:

\begin{enumerate}
    \item Kliknij przycisk \textbf{Save XMI} na pasku narzędzi
    \item Plik XMI zostanie automatycznie pobrany do folderu pobierania
    \item Plik zawiera pełną reprezentację diagramu, w tym pakiety, klasy, relacje oraz strukturę zagnieżdżeń
\end{enumerate}

\subsubsection{Importowanie diagramu z pliku XMI}

Aby załadować poprzednio zapisany diagram:

\begin{enumerate}
    \item Kliknij przycisk \textbf{Load XMI} na pasku narzędzi
    \item Wybierz plik XMI ze swojego komputera
    \item Diagram zostanie wczytany i wyświetlony na kanwie
    \item Wszystkie elementy automatycznie dostosowują swoją pozycję, aby uniknąć nakładania się
    \item Zagnieżdżone pakiety i klasy są poprawnie odtworzyme
\end{enumerate}

\small{\slshape{Wczytanie nowego diagramu spowoduje zastąpienie obecnego diagramu. Jeśli chcesz zachować bieżący diagram, wcześniej go zapisz.}}

\section{Generowanie kodu Python}

\subsection{Przygotowanie projektu}

Przed generowaniem kodu upewnij się, że Twój diagram spełnia następujące warunki:

\begin{itemize}
    \item Wszystkie klasy posiadają przypisane nazwy
    \item Atrybuty i operacje są poprawnie i kompletnie zdefiniowane
    \item Relacje między klasami są prawidłowo utworzone
    \item Klasy są przypisane do odpowiednich pakietów (zalecane, ale opcjonalne)
\end{itemize}

\subsection{Proces generowania kodu}

Aby wygenerować kod Python:

\begin{enumerate}
    \item Kliknij przycisk \textbf{Generate} na pasku narzędzi
    \item System automatycznie:
    \begin{itemize}
       \item Eksportuje diagram do formatu XMI
       \item Przesyła plik do serwera przetwarzającego
       \item Generuje pełny kod Python z dokumentacją
       \item Pakuje projekt w archiwum ZIP
    \end{itemize}
    \item Gotowe archiwum ZIP pobiera się automatycznie do folderu pobierania
\end{enumerate}

\subsection{Mapowanie typów danych}

Aplikacja automatycznie konwertuje typy danych UML na odpowiadające im typy Python:

\begin{table}[h!]
    \centering
    \footnotesize
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Typ UML} &
        \textbf{Typ Python} \\ \hline
        \texttt{String} &
        \texttt{str} \\ \hline
        \texttt{Integer} &
        \texttt{int} \\ \hline
        \texttt{Float} &
        \texttt{float} \\ \hline
        \texttt{Boolean} &
        \texttt{bool} \\ \hline
    \end{tabular}
    \caption{Mapowanie typów UML na typy w Pythonie}
    \label{tab:instrukcja_uml_mapowanie_typow}
\end{table}

Nazwy klas w typach danych są traktowane jako referencje do klas użytkownika i nie podlegają transformacji.

\section{Rozwiązywanie problemów}

\subsection{Kod nie został wygenerowany}

Jeśli kod Python nie generuje się prawidłowo, sprawdź:

\begin{itemize}
    \item Czy wszystkie klasy mają przypisane nazwy
    \item Konsolę przeglądarki w poszukiwaniu błędów JavaScript
    \item Logi serwera w poszukiwaniu błędów parsowania XMI
\end{itemize}

\subsection{Elementy nie są widoczne na kanwie}

Jeśli nie widzisz elementów na diagramie:

\begin{itemize}
    \item Sprawdź, czy elementy nie zostały przypadkowo przesunięte poza widoczny obszar
    \item Przybliż lub oddalź widok za pomocą kółka myszy
    \item Użyj przycisku \textbf{Clear} i zacznij od nowa
    \item Odśwież stronę w przeglądarce
\end{itemize}

W razie dodatkowych pytań lub problemów, sprawdź logi w konsoli przeglądarki, które mogą dostarczyć szczegółowych informacji o błędach.

\chapter{Podsumowanie i wnioski końcowe}

\section{Ocena stopnia realizacji projektu}

Opracowane narzędzie w pełni spełnia założone cele projektu i realizuje wszystkie wymagania funkcjonalne zdefiniowane w początkowych etapach pracy. Przeprowadzona implementacja obejmuje zarówno bibliotekę Pythonową do przetwarzania modeli UML, jak i kompletną aplikację webową umożliwiającą interaktywne tworzenie diagramów klas oraz automatyczne generowanie kodu źródłowego.

W aspekcie funkcjonalnym zrealizowano wszystkie zaplanowane komponenty: parser XMI obsługujący standard 2.1 z pełną obsługą pakietów zagnieżdżonych (\ref{WF-import1}--\ref{WF-import3}), relacji międzyklasowych (\ref{WF-relacje1}) oraz typów danych (\ref{WF-typy1}); generator kodu Python z właściwą mapą typów (\ref{WF-klasy1}--\ref{WF-klasy5}), wsparciem dla wszystkich sześciu typów relacji UML (asocjacja, agregacja, kompozycja, dziedziczenie, realizacja, zależność) oraz automatycznym zarządzaniem importami (\ref{WF-importy1}--\ref{WF-importy3}); oraz interfejs webowy umożliwiający intuicyjne tworzenie i edycję diagramów w przeglądarce (\ref{WF-klasa1}--\ref{WF-interakcje4}).

Zbudowana architektura oparta na wzorcu trójwarstwowym zapewnia czytelność kodu, łatwość testowania (\ref{WNF-modulowosc3}) oraz możliwość niezależnego wykorzystywania warstwy domenowej w innych projektach (\ref{WNF-modulowosc2}).

Testowanie metodą kombinacji testów jednostkowych (pytest) oraz weryfikacji manualnych potwierdziło poprawność działania wszystkich istotnych scenariuszy użycia (\ref{WNF-stabilnosc1}). Weryfikacja manualna potwierdziła intuicyjność interfejsu użytkownika (\ref{WNF-intuicyjnosc1}) oraz poprawne renderowanie diagramów UML w formacie SVG (\ref{WNF-czas2}).

Wydajność systemu spełnia zdefiniowane wymagania niefunkcjonalne (\ref{WNF-czas1}--\ref{WNF-czas3}), umożliwiając generowanie kodu dla projektów z 100 klas w czasie poniżej 5 sekund oraz zapewniając płynne renderowanie diagramów (30+ FPS) i responsywność interfejsu poniżej 100 ms (\ref{WNF-skalowalnosc1}).

\section{Ocena realizacji projektu z perspektywy komercyjnej i naukowej}

Z perspektywy komercyjnej i naukowej opracowane narzędzie zapełnia istotną lukę rynkową (\ref{WNF-dostepnosc1}). 

Wygenerowany kod Python spełnia standardy współczesnego programowania: zawiera type hints zgodne z PEP 484 (\ref{WNF-standardy3}), zachowuje hierarchię pakietów odpowiadającą strukturze UML (\ref{WF-struktura1}--\ref{WF-struktura3}) oraz jest gotowy do bezpośredniego użycia w projektach. Pozwala to na szybkie prototypowanie aplikacji oraz zmniejszenie czasu początkowych etapów wytwarzania oprogramowania.

\section{Możliwości dalszego rozwoju aplikacji}

Opracowane narzędzie stanowi solidną podstawę do dalszego rozszerzania funkcjonalności.
Kierunkami dalszego rozwoju mogą być zarówno rozszerzenia funkcjonalne, jak i usprawnienia techniczne.

\subsection{Rozszerzenia funkcjonalne}

\begin{itemize}
    \item Obsługa dodatkowych typów diagramów UML - Aktualnie aplikacja obsługuje wyłącznie diagramy klas. Naturalne rozszerzenie stanowiłoby dodanie obsługi diagramów sekwencji, aktywności, stanów czy przypadków użycia. Implementacja tych typów diagramów pozwoliłaby na pełną obsługę całego standardu UML i byłaby szczególnie wartościowa dla modelowania zaawansowanych systemów.

    \item Generowanie kodu dla innych języków programowania - Warstwa domenowa została zaprojektowana z myślą o rozszerzalności. Logika parsowania i transformacji modelu jest niezależna od docelowego języka programowania. Dodanie obsługi dla Java, C\#, TypeScript czy Go wymagałoby jedynie implementacji nowych szablonów kodu oraz mapowania typów. Takie podejście znacznie rozszerzyłoby grono potencjalnych użytkowników.

    \item Generowanie logiki biznesowej - Aktualnie system generuje jedynie szkielety metod. Zaawansowaną funkcjonalnością byłoby generowanie pełnej logiki biznesowej na podstawie semantyki definiowanej w diagramach, na przykład automatyczne generowanie getterów/setterów, implementacji interfejsów czy obsługi walidacji. Mogłoby to być wspomagane przez integrację z modelami LLM (Large Language Models), które na podstawie opisu biznesowego w komentarzach mogłyby generować działający kod.

    \item Reverse engineering - generowanie diagramów z kodu - Implementacja analizy istniejącego kodu Python i konwersji go na diagramy UML stanowiłaby pełny cykl Model-Driven Development. Funkcjonalność ta wymagałaby zaawansowanej analizy kodu źródłowego oraz ekstrahowania informacji o klasach, atrybutach, metodach i relacjach.

    \item Walidacja i weryfikacja diagramów - System mógłby sprawdzać poprawność modelu w kontekście najlepszych praktyk projektowania: detekcja cykli w hierarchii dziedziczenia, wskazanie naruszeń zasad SOLID, analiza kompleksowości struktury czy sugestie dotyczące refaktoryzacji.

    \item Wspólne edycje i kontrola wersji - Integracja z systemami kontroli wersji (Git) w celu obsługi wieloosobowych sesji edycji, automatycznego śledzenia zmian modelu i możliwości cofania operacji. Wspólne edycje wymagałyby implementacji mechanizmu konfliktów rozstrzygania zmian oraz synchronizacji stanów między klientami.

    \item Analityka i metryki modelu - System mógłby przygotowywać raporty na temat modelu: liczba klas, głębokość hierarchii dziedziczenia, stopień sprzężenia, złożoność struktury. Metryki te mogłyby być wizualizowane i służyć do identyfikacji potencjalnych problemów architektonicznych.

    \item Integracja z IDE - Rozszerzenie wtyczek dla popularnych edytorów (Visual Studio Code, JetBrains IDE) umożliwiłoby użytkownikom pracę z diagramami bez opuszczania ich głównego środowiska programistycznego.

    \item Generacja dokumentacji - Automatyczne tworzenie dokumentacji technicznej na podstawie modelu UML: diagramy, opisy architektoniczne, słowniki konceptów, mapy zależności modułów.
\end{itemize}

\subsection{Prace badawcze}

\begin{itemize}
    \item Empiryczna ocena efektywności MDD w Pythonie - Przeprowadzenie badań z udziałem programistów w celu zmierzenia rzeczywistego przyspieszenia wytwarzania oprogramowania przy zastosowaniu narzędzia oraz jakości wygenerowanego kodu.

    \item Porównanie z innymi podejściami - Analiza różnic między generowaniem kodu z modeli a organicznym rozwojem kodu bez fazy modelowania pod kątem długoterminowej utrzymywalności i elastyczności systemów.
\end{itemize}

\begin{thebibliography}{13}

    \bibitem{omg_uml} Object Management Group, \emph{OMG Unified Modeling Language (UML) Version 2.5.1}, formal/17-12-05, \url{https://www.omg.org/spec/UML/2.5.1/}

    \bibitem{omg_xmi} Object Management Group, \emph{XML Metadata Interchange (XMI) Version 2.1.1}, formal/12-05-01, \url{https://www.omg.org/spec/XMI/2.1.1/}

    \bibitem{france_mdd} France R., Rumpe B., \emph{Model-driven Development of complex Software: A Research Roadmap}, Future of Software Engineering Research, ACM, 2010

    \bibitem{pep484} Python Software Foundation, \emph{typing -- Support for type hints}, Python 3.12 Documentation, \url{https://docs.python.org/3/library/typing.html}

    \bibitem{fastapi} Tiobe Software, \emph{FastAPI Documentation: High-Performance Python Web Framework}, \url{https://fastapi.tiangolo.com/}

    \bibitem{enterprise_arch} Sparx Systems, \emph{Enterprise Architect User Guide v16}, Sparx Systems Pty Ltd, \url{https://sparxsystems.com/enterprise_architect_user_guide/}

    \bibitem{visual_paradigm} Visual Paradigm International, \emph{Visual Paradigm User Manual}, \url{https://www.visual-paradigm.com/support/documents/vpuserguide/}

    \bibitem{staruml} Plastic Software Inc., \emph{StarUML Documentation v6.0}, \url{https://docs.staruml.io/}

    \bibitem{plantuml} PlantUML Team, \emph{PlantUML Documentation}, \url{https://plantuml.com/}

    \bibitem{drawio} JGraph Ltd., \emph{diagrams.net (draw.io) Technical Documentation}, \url{https://www.diagrams.net/doc/}

    \bibitem{clean_arch} Martin R.C., \emph{Clean Architecture: A Craftsman's Guide to Software Structure and Design}

    \bibitem{pytest_okken} Okken B., \emph{Python Testing with pytest, Second Edition}, Pragmatic Bookshelf, 2022

\end{thebibliography}

\end{document}